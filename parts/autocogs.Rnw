\chapter{Automatic Cognostics}

From a data plotting perspective, we should be able to utilize what is already being displayed in the plot to sort and filter the panels of a \trelliscopejs widget.  This display information is not readily available as it is calculated within the plotting mechanism.

Using the prior \rinline{gapminder} example, the $X$ and $Y$ locations of the data must be retrieved manually.  While the prior example only retrieved the minimum and maximum values for each panel, the median and mean values may be of interest as well. These statistics are only looking at the $Y$ variable.  There are many more statistics involving both the $Y$ variable and the $X$ variable.  The $X$ and $Y$ covariance and correlation are added.  A linear model (\rinline{geom_smooth(method = "lm")}) was also added to visually detect linear trend deviations.

<< add_metrics >>=
gapminder_condensed %>%
  mutate(
    # add metrics
    min_lifeExp = purrr::map_dbl(data, function(dt) min(dt$lifeExp)),
    mean_lifeExp = purrr::map_dbl(data, function(dt) mean(dt$lifeExp)),
    median_lifeExp = purrr::map_dbl(data, function(dt) median(dt$lifeExp)),
    max_lifeExp = purrr::map_dbl(data, function(dt) max(dt$lifeExp)),
    cov = purrr::map_dbl(data, function(dt) cov(dt$year, dt$lifeExp)),
    corr = purrr::map_dbl(data, function(dt) cor(dt$year, dt$lifeExp)),

    # add panel
    panel = map_plot(data, function(dt) {
      # display a line plot of X:year, Y:life expectancy
      ggplot(dt, aes(year, lifeExp)) +
        geom_smooth(method = "lm") +
        geom_line() +
        ylim(20, 85)
    })
  ) %>%
  # remove the condensed data
  select(-data) %>%
  print() ->
gap_trellis_plus

gap_trellis_plus %>%
  trelliscope("gapminder", nrow = 3, ncol = 5, path = "example/gapminder_plus")
@

The amount of work to retrieve information that can be readily seen or calculated from the visual display quickly increases.  At first, there were two values used.  Now there are six values used to explain just the $Y$ data and the $\left\{X,Y\right\}$ combination.  As the amount of layers increase, the number of cognostics needed to explain the plot layer will also increase.  Given each plotting panel already contains statistical information, it should be leveraged to generate cognostics automatically.





\subsection{Example}

Using the panel column only, we will derive many cognostics using the \autocogs R package.

<< autocogs_first >>=
gapminder %>%
  group_by(country, continent) %>%
  tidyr::nest() %>%
  mutate(
    panel = map_plot(data, function(dt) {
      # display a line plot of X:year, Y:life expectancy
      ggplot(dt, aes(year, lifeExp)) +
        geom_smooth(method = "lm") +
        geom_line() +
        ylim(20, 85)
    })
  ) %>%
  select(-data) %>% # remove the condensed data
  print() ->
gap_panel

autocogs::add_panel_cogs(gap_panel)
@

For each panel, \rinline{2 + 19 + 5 + 5 + 2 + 5 = 38} cognostics were auto generated to aid in exploration of the panels.

  \begin{enumerate}
    \item Ten of the cognostics calculate information individual column information. (\rinline{_x}, \rinline{_y})
    \item Two cognostics calculate continuous bivariate metrics. (\rinline{_bivar})
    \item Five cognostics calculate metrics involving the number of points and their availbility. (\rinline{_n})
    \item Two cognostics calculate metrics for the smooth line added to each panel. (\rinline{_smooth})
    \item Nineteen cognostics are calculated for the linear model applied to the panel.  These metrics will be dicussed in greater detail later. (\rinline{_lm})
  \end{enumerate}

Each univariate grouping is labeled to provide context as to what is calculated and which variables were used.






\subsection{Framework}

\autocogs package was built to provide a consistent framework for calculating cognostics independent of the class of the plotting supplied.  Ideally, it should work for \ggplot, \pkg{rbokeh}, \pkg{plot.ly}, etc. and produce the same result for similar plot displayed in the different plotting packages.  Currently, only \ggplot hooks have been installed, but \pkg{rbokeh} and \pkg{plot.ly} can be added using the publically available functions in the \autocogs package.


By definition, each subset panel within trelliscopejs will contain the same plotting layers, only with different data.  Addressing each layer will produce the same group of output cognostics but with different values.  There is a ``one to many'' mapping from plot to plot layers and a ``one to many'' mapping from plot layers to cognostics.  These same final cognostics can be produced from many different layers.

\includegraphics[width = \textwidth ]{./dot/plot_layers.pdf}

Once all the cognostics have been produced for a given plot, they are reduced to keep only the unique cognostic name and value combinations.  Using the diagram above, the cognostic groups $\left\{A, B, ..., M\right\}$ will be returned once.











\subsection{Cognostic Groups}

Each set of cognostics is returned in a cognostic group.  This is similar to scagnostics.  Scagnostics all pertain to scatterplots.  Likewise, the number of non-NA X, non-NA Y, and non-NA X and Y points are pertain to non-NA counts of the displayed data.  These groups can be extended to each type of graphical display: box plot, histogram, linear model, etc.

The cognostics produced in the autocog gapminder example (TODO LINK TO EXAMPLE) were:
\begin{enumerate}
  \item \rinline{_smooth}: Two cognostics pertaining to a ``smooth'' line being added to the panel.
  \item \rinline{_lm}: Nineteen cognostics pertaining to the linear model line added to the panel.
  \item \rinline{_x, _y} Five cognostics pertaining only to the X and Y values respectively.
  \item \rinline{_bivar} Two cognostics pertaining only to both the X and Y values.
  \item \rinline{_n} Five cognostics pertaining only to counts of X and Y values.
\end{enumerate}

Each cognostic group column contains a single row data frame nested in each cell.  Nesting data structures is considered an advanced technique, but by nesting the cognostic data frames in each cell, \autocogs maintains the tidy data input with tidy data output.  Tidy data is defined to have variables in each column, observations for each row and each cell contains a value.  The value does not need to conform to atomic values but allows for complex structures as long as the ``tidy data'' rules are kept.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figs/tidy.png}
  \caption{Figure taken from \cite{r4ds}. ``Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells.'' (\cite{r4ds})}
\end{figure}












\section{Cognostic Groups}

There are three main types of cognostic groups: Univariate group, Bivariate group, and the Counts group.  Each type of cognostic group will explain in detail their corresponding cognostic groups in detail throughout this section.

\subsection{Univariate}

The univariate cognostic groups will explore the same dataset of the maximum life expectancy of the \rinline{gapminder} data set.

<<>>=
gapminder %>%
  group_by(country, continent) %>%
  summarise(lifeExp = max(lifeExp)) %>%
  print() ->
gap_max

ggplot(gap_max, aes(lifeExp, fill = continent)) +
  geom_histogram(binwidth = 1) +
  labs(x = "max(lifeExp)")
@

\begin{enumerate}


  \item Boxplot Cognostics

  Boxplot metrics include lower whisker, Q1, median, Q3, and upper whisker locations.  The number of outliers above the boxplot and below the boxplot are added as well.

<< cog_group_boxplot >>=
autocogs::auto_cog("boxplot", gap_max$lifeExp)
@

  \item Continuous Density Cognostics

  Continuous density cognostics revolve around the shape of the density.  The maximum density value and its corresponding location are returned for comparison across cognostic calculations. Skew (CITE) and kurtosis (CITE) are readily available to help distinguish the density shape as well as the p value of Hartigans' dip test from \pkg{diptest} (CITE) for unimodality.  To help locate where the maximum density occurs, the max density value and location are also provided.  Finally, not by default due to slow calculation speed, the number of clusters may be calculated using the \pkg{mclust} (CITE) R package.


<< cog_group_density_continuous >>=
autocogs::auto_cog("density_continuous", gap_max$lifeExp, clusters = TRUE)
@


  \item Quantile Quantile Cognostics

Quantile-Quantile plots display the theoretical distribution quantiles verses the sample quantile points.  Two indicator variables to help determine skewness provide how many points are above and below a non robust quantile line.  The non robust quantile line is calculated using the $25^{th}$ and $75^{th}$ percentiles of sample points, rather than the a robust linear model.  This calculation replicates the base R function \rinline{stats::qqline}.  A p value for the Kolmogorov-Smirnov test is added to the result to determine how close the sample points come from the test distribution.  The test distribution defaults to the normal distribution.  Finally, a mean squared error from the quantile line is reported for the Quantile-Quantile plot.  This value should be comparable to all of the independent samples as each sample should come from the same distribution.  Larger mean squared error values help discover outliers in the distribution.

<< cog_group_quantile_quantile >>=
autocogs::auto_cog("quantile_quantile", gap_max$lifeExp)
@

  \item Univariate Cotinuous Cognostics

  Univariate continuous cognostics utilize the standard statistical calculations: minimum, maximum, mean, median, and variance.  Each value is quickly interpretable and provides a good starting point when filtering panels within a \trelliscopejs widget.

<< cog_group_univariate_continuous >>=
autocogs::auto_cog("univariate_continuous", gap_max$lifeExp)
@

  \item Univariate Discrete Cognostics

  Univariate discrete values only have counts and names to determine the cognostics.  The minimum and maximum count values are reported, as well as the mean count value.  For both the minimum and maximum values, a corresponding name is reported alongside the count.  The example below shows that the continent \rinline{"Africa"} contains the most countries at \rinline{52} and \rinline{"Oceania"} contains least amount of countries at \rinline{2} countries.

<< cog_group_univariate_discrete >>=
autocogs::auto_cog("univariate_discrete", gap_max$continent)
@

\end{enumerate}


\subsection{Bivariate}

The cognostic groups below will be calculated using the \rinline{gapminder} dataset where continent equals \rinline{"Americas"}, (\rinline{americas}), or where country equals \rinline{"United States"}, (\rinline{usa}).

<< gap_americas >>=
americas <- gapminder %>% filter(continent == "Americas")
usa <- gapminder %>% filter(country == "United States")
@

  \item Bivariate Continuous Cognostics

Similar to the Univariate Continuous cognostic group, the Bivariate Continuous cognostic group calculates the two standard bivariate summary statistics: covariance and correlation.

<< cog_group_bivariate_continuous >>=
autocogs::auto_cog("bivariate_continuous", usa$year, usa$lifeExp)
@

  \item Bivariate Step Cognostics

  A stepwise plot displays a ``stair case'' like plot where the connecting line only moves along the $X$ or $Y$ axis.  The Bivariate Step cognostic group returns the number of steps completed, as well as the Univariate Continuous cognostics on the step width and step height.

<< cog_group_bivariate_step >>=
autocogs::auto_cog("bivariate_step", usa$year, usa$lifeExp)
@

  \item Continuous 2D Density Cognostics

The Continuous 2-Dimensional Density cognostic group reports the maximum density $X$ and $Y$ location are returned, similar to the Continuous Density cognostic group.  Also similar to the Continuous Density cognostic group, cluster count calculations are turned off by default.


<< cog_group_density_2d_continuous >>=
autocogs::auto_cog("density_2d_continuous", americas$year, americas$lifeExp, clusters = TRUE)
@

  \item Linear Model Cognostics

Linear Model cognostics leverage the vast array of existing statistics.  Knowning that the model will only be a simple linear model allows \autocogs to return slope and intercept values and corresponding p values.  Many cognostics can be generated about the model fit using known diagnostic methods:
  \begin{enumerate}
    \item $R^2$: fraction of variance explained by the model
    \item sigma: square root of the estimated residual variance
    \item F-statistic: the linear model's F-statistic and corresponding p value.
    \item degrees of freedom: how many degrees of freedom in the model and residuals
    \item log-likelihood value: the log likelihood value of the model
    \item AIC, BIC: Akaike's Information Criterion and Schwarz's Bayesian Criterion
    \item deviance: the quality-of-fit statistic of the model
  \end{enumerate}

  There are a few extra diagnostics that are massaged to conform to the univariate requirement of a cognostic.

  \begin{enumerate}
    \item Cook's Distance: a combination of each points leverage and residual value.  Values larger than $4 / n$ indicate influential data points in the model.  A number of influential data points is reported.
    (CITE Bollen, Kenneth A.; Jackman, Robert W. (1990). Fox, John; Long, J. Scott, eds. Regression Diagnostics: An Expository Treatment of Outliers and Influential Cases. Modern Methods of Data Analysis. Newbury Park, CA: Sage. pp. 257â€“91. ISBN 0-8039-3366-5.)
    \item Influence Points: the diagonal of the Hat Matrix is consided to be how much influce a point has on the model.  Each point is expected to equal $\dfrac{p}{n} = \dfrac{1}{n}$, with influential points having a value larger than $\dfrac{2 * p}{n} = \dfrac{2}{n}$ \cite{kutner_linear_models}.  The number reported is the sum of all influential points.
    \item Shapiro-Wilk Test: when using a linear model, the residuals are assumed to come from a normal distribution.  The Shapiro-Wilk test tests the residuals agains the normal distribution \cite{kutner_linear_models}.  The corresponding p value is reported.
    \item Box Cox power transformation: the lower and upper bounds of a 95\% confidence interval of the Box Cox power tranformation are reported. This transformation is useful when trying to stabilize the variance.
  \end{enumerate}


<< cog_group_linear_model >>=
as.data.frame(autocogs::auto_cog("linear_model", usa$year, usa$lifeExp))
@

  \item Loess Model Cognostics

  Similar to the linear model, a simple loess model is calculated and diagnosed.
  \begin{enumerate}
    \item Supplied parameters: the supplied parameters of \rinline{span}, the alpha parameter which controls the degree of smoothing, and \rinline{degree}, the polynomial degree used in the loess model, are returned.
    \item Calculated parameters: the calculated effective number of parameters \rinline{enp} is returned along with the trace of the hat matrix \rinline{trace.hat}.  Finally, the sigma value of the loess model variance is returned as a single cognostic.
    \item
  \end{enumerate}

<< cog_group_loess_model >>=
autocogs::auto_cog("loess_model", usa$year, usa$lifeExp)
@

  \item Scagnostics Cognostics

  Scatterplot scagnostics are pre-existing cognostic group for a continuous bivariate plot. The following scagnostics are explained in more detail in \cite{scagnostics}.

  \begin{enumerate}
    \item Outlying: the proportion of the total edge length due to extremely long edges connected to points of single degree
    \item Skewed: the distribution of edge lengths of a minimum spanning tree gives us information about the relative density of points in a scattered configuration
    \item Clumpy: the Hartigan and Mohanty RUNT statistic is most easily understood in terms of the single-linkage hierarchical clustering tree called a dendrogram
    \item Sparse, the 90\% quantile of the edge lengths of the minimum spaning tree
    \item Striated: the sumation of angles over all adjacent edges of a MST
    \item Convex: the ratio of the area of the alpha hull and the area of the convex hull
    \item Skinny: the ratio of perimeter to area of a polygon measures
    \item Stringy: the ratio of width to length of a network
    \item Monotonic: squared Spearman correlation coefficient
  \end{enumerate}

<< cog_group_scagnostics >>=
autocogs::auto_cog("scagnostics", americas$year, americas$lifeExp)
@

  \item Smooth Line Cognostics

  The smooth line cognostic group is a baseline for all model based lines added to a plot.  The smooth line calculations pair well with the linear model and loess model cognostic groups.  A mean squared error and the max deviation with its corresponding location are reported

<< cog_group_smooth_line >>=
autocogs::auto_cog("smooth_line", usa$year, usa$lifeExp)
@



\subsection{Counts}

\item Hexagonal Counts Cognostics

<< cog_group_hex_counts >>=
autocogs::auto_cog("hex_counts", americas$year, americas$lifeExp)
@

\item Square Counts Cognostics

<< cog_group_square_counts >>=
autocogs::auto_cog("square_counts", americas$year, americas$lifeExp)
@


\item Bivariate Count Cognostics

<< cog_group_bivariate_counts >>=
autocogs::auto_cog("bivariate_continuous", americas$year, americas$lifeExp)
@


\item \rinline{"univariate_counts"}

\item \rinline{"histogram_counts"}
<< cog_group_histogram_counts >>=
autocogs::auto_cog("histogram_counts", gap_max$lifeExp, clusters = TRUE)
@
  grouped_counts
  % grouped_testing
  pairwise_counts


\section{\ggplot Layer Matching}


% #' Cog group data frame
% #'
% #' Make a cog group data grame to be passed into \code{\link{add_layer_cogs}}
% #' @param ... sets of three values to fill in 'cog_group', 'cols', and 'name'
% #' @export
% #' @examples
% #' cog_group_df(
% #'   "univariate_discrete", "x", "_x",
% #'   "univariate_counts", "x", "_n"
% #' )
% #' cog_group_df(
% #'   "univariate_continuous", "x", "_x",
% #'   "univariate_continuous", "y", "_y",
% #'   "bivariate_continuous", c("x", "y"), "_bivar",
% #'   "scagnostics", c("x", "y"), "_scagnostic",
% #'   "bivariate_counts", c("x", "y"), "_n"
% #' )
% cog_group_df <- function(...) {
%   tibble::tribble(
%     ~ cog_group, ~ cols, ~ name,
%     ...
%   )
% }
%
% #   geom_bar geom_col stat_count
% #     - Bars charts
% #     * univariate_counts(x)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(x...)
% add_layer_cogs(
%   # load_all(); p <- qplot(Sepal.Length, data = iris, geom = "bar"); print(p); plot_cogs(p)
%   "geom_bar",
%   "bar plot. (height is calculated)",
%   cog_group_df(
%     "univariate_discrete", "x", "_x",
%     "univariate_counts", "x", "_n"
%   )
% )
% add_layer_cogs(
%   # load_all(); p <- qplot(Sepal.Length, Sepal.Width, data = iris, geom = "col"); print(p); plot_cogs(p)
%   "geom_col",
%   "bar plot with known height",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
% #   geom_hex stat_bin_hex
% #     - Hexagonal heatmap of 2d bin counts
% #     * bivariate_counts(x, y)
% #     * chi_square_test(bin_counts)
% add_layer_cogs(
%   # load_all(); p <- qplot(carat, price, data = diamonds, geom = "hex"); print(p); plot_cogs(p)
%   "geom_hex",
%   "hexegon density plot",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "hex_counts", c("x", "y"), "_hex_bins",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
% #   geom_bin2d stat_bin_2d
% #     - Heatmap of 2d bin counts
% #     * bivariate_counts(x, y)
% #     * chi_square_test(bin_counts)
% add_layer_cogs(
%   # load_all(); p <- qplot(carat, price, data = diamonds, geom = "bin2d"); print(p); plot_cogs(p)
%   "geom_bin2d",
%   "hexegon density plot",
%   cog_group_df(
%     "square_counts", c("x", "y"), "_square_bins",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
% #   geom_point
% #     - Points
% #     * univariate_continuous(x)
% #     * univariate_continuous(y)
% #     * bivariate_continuous(x,y)
% #     * bivariate_counts(x,y)
% #     * bivariate_scagnostics(x,y)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(y...)
% #   geom_jitter
% #     - Jittered points
% #     * univariate_continuous(x)
% #     * univariate_continuous(y)
% #     * bivariate_continuous(x,y)
% #     * bivariate_counts(x,y)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(y...)
% add_layer_cogs(
%   # load_all(); p <- qplot(Sepal.Length, Sepal.Width, data = iris); plot_cogs(p)
%   "geom_point",
%   "scatter plot points",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "scagnostics", c("x", "y"), "_scagnostic",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
% #   geom_boxplot stat_boxplot
% #     - A box and whiskers plot (in the style of Tukey)
% #     * univariate_continuous(x)
% #     * univariate_boxpot(x)
% #     ^ univariate_counts(x)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(x...)
% #     ** ('n_outlier_lower', 'count of lower outliers')
% #     ** ('min_non_outlier', 'minimum point')
% #     ** ('max_non_outlier', 'maximum non outlier point')
% #     ** ('n_outlier_upper', 'count of upper outliers')
% add_layer_cogs(
%   # load_all(); p <- qplot(x = 1, y = Sepal.Length, data = iris, geom = "boxplot"); plot_cogs(p)
%   "geom_boxplot",
%   "boxplot plot",
%   cog_group_df(
%     "univariate_continuous", "y", "_y",
%     "boxplot_metrics", "y", "_boxplot",
%     "univariate_counts", "y", "_n"
%   )
% )
%
%
% #   geom_count stat_sum
% #     - Count overlapping points
% #     * expected count(x)
% #     * bivariate_counts(x, y)
% #     ** grouped_counts(counts...)
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "count"); plot_cogs(p)
%   "geom_count",
%   "count of discrete scatter plot points",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "univariate_discrete", "x", "_x_counts",
%     "univariate_discrete", "y", "_y_counts",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "pairwise_counts", c("x", "y"), "_xy_counts",
%     "scagnostics", c("x", "y"), "_scagnostic",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
% #   geom_density stat_density
% #     - Smoothed density estimates
% #     * ('max_density', 'maximum density value')
% #     * univariate_continuous(x)
% #     ** grouped_testing(x...)
% #     ** grouped_counts(counts...)
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, data = mpg, geom = "density"); plot_cogs(p)
%   "geom_density",
%   "density of a single variable",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "density_continuous", "x", "_density",
%     "univariate_counts", "x", "_n"
%   )
% )
% #   geom_violin stat_ydensity
% #     - Violin plot
% #     * ('max_density', 'maximum density value')
% #     * univariate_continuous(x)
% #     ** grouped_testing(x...)
% #     ** grouped_counts(counts...)
% add_layer_cogs(
%   # load_all(); p <- qplot(1, cty, data = mpg, geom = "violin"); plot_cogs(p)
%   "geom_violin",
%   "density of a single y variable",
%   cog_group_df(
%     "univariate_continuous", "y", "_y",
%     "density_continuous", "y", "_violin",
%     "univariate_counts", "y", "_n"
%   )
% )
%
% #   geom_density_2d stat_density_2d
% #     - Contours of a 2d density estimate
% #     * max density(x, y)
% #     * bivariate_continuous(x,y)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(y...)
% add_layer_cogs(
%   # load_all(); p <- qplot(carat, price, data = diamonds[1:1000, ], geom = "density_2d"); plot_cogs(p)
%   "geom_density2d",
%   "Contours of a 2d density estimate. Similar to a topographical map",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "density_continuous", c("x"), "_density_x",
%     "density_continuous", c("y"), "_density_y",
%     "density_2d_continuous", c("x", "y"), "_density2d",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
%
% #   geom_dotplot
% #     - Dot plot
% #     * univariate_continuous(x)
% #     * univariate_counts(x)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(x...)
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, data = mpg, geom = "dotplot"); plot_cogs(p)
%   # TODO could be done better
%   "geom_dotplot",
%   "stacked dots where each dot represents an observation.  The width of the dot represents the bin width.",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "density_continuous", c("x"), "_density_x",
%     "univariate_counts", c("x"), "_n"
%   )
% )
%
%
% #   geom_freqpoly geom_histogram stat_bin
% #     - Histograms and frequency polygons
% #     * univariate_continuous(x)
% #     * univariate_counts(x)
% #     * univariate_continuous(counts)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(x...)
% add_layer_cogs(
%   # load_all(); p <- qplot(Sepal.Length, data = iris, geom = "histogram"); plot_cogs(p)
%   "geom_histogram",
%   "histogram of continuous data",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "density_continuous", c("x"), "_density_x",
%     "histogram_counts", c("x"), "_hist_x",
%     "univariate_counts", c("x"), "_n"
%   )
% )
%
%
% #   geom_rug
% #     - Rug plots in the margins
% #     * univariate_continuous(x)
% #     * univariate_counts(x)
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(x...)
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, data = mpg, geom = "rug"); plot_cogs(p)
%   "geom_rug_x",
%   "Rug plots in the margins",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "density_continuous", c("x"), "_density_x",
%     "univariate_counts", c("x"), "_n"
%   )
% )
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, data = mpg, geom = "rug"); plot_cogs(p)
%   "geom_rug_y",
%   "Rug plots in the margins",
%   cog_group_df(
%     "univariate_continuous", "y", "_y",
%     "density_continuous", c("y"), "_density_y",
%     "univariate_counts", c("y"), "_n"
%   )
% )
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, data = mpg, geom = "rug"); plot_cogs(p)
%   "geom_rug_xy",
%   "Rug plots in the margins",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "density_continuous", c("x"), "_density_x",
%     "density_continuous", c("y"), "_density_y",
%     "univariate_counts", c("x"), "_n_x",
%     "univariate_counts", c("y"), "_n_y"
%   )
% )
%
%
%
% #   geom_spoke
% #     - Line segments parameterised by location, direction and distance
% #     * univariate_continuous(angle) | angle is aes
% #     * univariate_continuous(spoke) | spoke is aes
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(angle...)
% #     ** grouped_testing(spoke...)
% add_layer_cogs(
%   # load_all(); p <- qplot(Sepal.Length, Sepal.Width, radius = ~ Petal.Length, spoke = ~ Petal.Width, data = iris, geom = "spoke"); plot_cogs(p)
%   "geom_spoke",
%   "Spoke plot of continuous data",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "density_continuous", c("x"), "_density_x",
%     "univariate_continuous", "y", "_y",
%     "density_continuous", c("y"), "_density_y",
%     "univariate_continuous", "angle", "_angle",
%     "density_continuous", c("angle"), "_density_angle",
%     "univariate_continuous", "radius", "_radius",
%     "density_continuous", c("radius"), "_density_radius",
%     "bivariate_counts", c("x", "y"), "_n_xy",
%     "bivariate_counts", c("angle", "radius"), "_n_angle_radius"
%   )
% )
%
%
% #   geom_qq stat_qq
% #     - A quantile-quantile plot
% #     * sum of delta^2 | above
% #     * sum of delta^2 | below
% #     * sum of delta^2
% #     * KS test (x, dist)
% add_layer_cogs(
%   # load_all(); p <- qplot(sample = Sepal.Length, data = iris, geom = "qq"); print(p); plot_cogs(p)
%   "geom_qq",
%   "Quantile-Quantile plot of continuous data",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "quantile_quantile", "x", "_qq"
%   )
% )
%
%
%
%
% #   geom_smooth stat_smooth
% #     - Smoothed conditional means
% #     * bivariate_counts(x,y)
% #     ^ linear_model(x, y)
% #     ** linear_model(x, y, group)
% #     ** group variable significance (intercept)
% #     ** group and x interaction significance (slope)
% #     ** grouped_counts(counts...)
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "smooth"); plot_cogs(p)
%   "geom_smooth",
%   "Smooth line plot of continuous x-y data",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "smooth_line", c("x", "y"), "_smooth",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "smooth", method = "loess", span = 0.9, method.args = list(degree = 1)); plot_cogs(p)
%   "geom_smooth_loess",
%   "Loess plot of continuous x-y data",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "smooth_line", c("x", "y"), "_smooth",
%     "loess_model", c("x", "y"), "_loess",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
% add_layer_cogs(
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "smooth", method = "lm"); plot_cogs(p)
%   "geom_smooth_lm",
%   "Smooth line plot of continuous x-y data",
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "smooth_line", c("x", "y"), "_smooth",
%     "linear_model", c("x", "y"), "_lm",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
% # geom_path geom_line
% add_layer_cogs(
%   "geom_line",
%   "Line plot (with data sorted by x) of continuous data",
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "line"); plot_cogs(p)
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
% add_layer_cogs(
%   "geom_path",
%   "Line Path plot of continuous data",
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "path"); plot_cogs(p)
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
% add_layer_cogs(
%   "geom_step",
%   "Line Step plot of continuous data",
%   # load_all(); p <- qplot(cty, hwy, data = mpg, geom = "step"); plot_cogs(p)
%   cog_group_df(
%     "univariate_continuous", "x", "_x",
%     "univariate_continuous", "y", "_y",
%     "bivariate_step", c("x", "y"), "_step",
%     "bivariate_continuous", c("x", "y"), "_bivar",
%     "bivariate_counts", c("x", "y"), "_n"
%   )
% )
%
%
% # Maybe Nothing?
% #   geom_contour stat_contour
% #     - 2d contours of a 3d surface
% #   geom_path geom_line geom_step
% #     - Connect observations
% #   geom_raster geom_rect geom_tile
% #     - Rectangles
% #
% # Nothing
% #   geom_abline geom_hline geom_vline
% #     - Reference lines: horizontal, vertical, and diagonal
% #   geom_blank
% #     - Draw nothing
% #   geom_errorbarh
% #     - Horizontal error bars
% #   geom_crossbar geom_errorbar geom_linerange geom_pointrange
% #     - Vertical intervals: lines, crossbars & errorbars
% #   geom_map
% #     - Polygons from a reference map
% #   geom_polygon
% #     - Polygons
% #   geom_ribbon geom_area
% #     - Ribbons and area plots
% #   geom_segment geom_curve
% #     - Line segments and curves
% #   geom_label geom_text
% #     - Text
% #   stat_sf geom_sf coord_sf
% #     - Visualise sf objects
%
%
% ## NONE
% #   geom_quantile stat_quantile
% #     - Quantile regression
% #     ^ contains N points
% #     ^ contains N points above
% #     ^ contains N points below
% #     ^ integral of area
% #     ** contains N points in group
% #     ** contains N points above in group
% #     ** contains N points below in group
% #     ** integral of area in group
% #     ** grouped_counts(counts...)
% #     ** grouped_testing(y...)




\section{Extra}

For any data types
  Can be linear models, box plots, etc.
Example of gapminder linear model and $R^2$


Autocogs
  Framework
    Connect to plotting frameworks,
      Short paragraph (and example?) on each one
      Ggplot2 layers
        $Geom_point$
        $Geom_line$
        etc...


\subsection{Caluclations}






TODO keep writing




















Using the \rinline{gapminder} dataset as an example, we can explore the linear model trend of the life expectancy over time.

%\trelliscopejs has integrated functionality with \ggplot, so we will reduce the amount of code using the function \rinline{facet_trelliscope}.

<< all_info  >>=
gapminder_condensed %>%
  mutate(
    # add metrics
    min_lifeExp = purrr::map_dbl(data, function(dt) min(dt$lifeExp)),
    max_lifeExp = purrr::map_dbl(data, function(dt) max(dt$lifeExp)),
    # add panel
    panel = map_plot(data, function(dt) {
      # display a line plot of X:year, Y:life expectancy
      ggplot(dt, aes(year, lifeExp)) +
        geom_smooth(method = "lm") +
        geom_line() +
        ylim(20, 85)
    })
  ) %>%
  # remove the condensed data
  select(-data) %>%
  print() ->
gap_trellis

# display the plots and metrics in trelliscopejs
gap_trellis %>%
  trelliscope("gapminder", nrow = 3, ncol = 5, path = "example/gapminder")
@

<< lm_facet >>=
gapminder %>%
  ggplot(aes(year, lifeExp)) +
    geom_line() +
    geom_smooth(method = "lm") +
    facet_trelliscope(~ continent + country, nrow = 3, ncol = 5, path = "example/gapminder_facet")
@

Each panel contains a linear model that can be used to interpret each countries' life expectancy over time.  The linear model information contained within each panel is not calculated until \ggplot displays the plot.  Information within each model can be useful when sorting panels within trelliscopejs.  This




Future work
  Add cognostics for time series data
  Add safety layer for the execution (try catch)
  Add message similar to $facet_map$ to submit them to github
  Add rbokeh layer connections
  Add plotly layer connections
