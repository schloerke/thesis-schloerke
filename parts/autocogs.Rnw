\chapter{Automatic Cognostics}

From a data plotting perspective, we should be able to utilize what is already being displayed in the plot to sort and filter the panels of a \trelliscopejs widget.  This display information is not readily available as it is calculated within the plotting mechanism.

Using the prior \rinline{gapminder} example, the $X$ and $Y$ locations of the data must be retrieved manually.  While the prior example only retrieved the minimum and maximum values for each panel, the median and mean values may be of interest as well. These statistics are only looking at the $Y$ variable.  There are many more statistics involving both the $Y$ variable and the $X$ variable.  The $X$ and $Y$ covariance and correlation are added.  A linear model (\rinline{geom_smooth(method = "lm")}) was also added to visually detect linear trend deviations.

<< add_metrics >>=
gapminder_condensed %>%
  mutate(
    # add metrics
    min_lifeExp = purrr::map_dbl(data, function(dt) min(dt$lifeExp)),
    mean_lifeExp = purrr::map_dbl(data, function(dt) mean(dt$lifeExp)),
    median_lifeExp = purrr::map_dbl(data, function(dt) median(dt$lifeExp)),
    max_lifeExp = purrr::map_dbl(data, function(dt) max(dt$lifeExp)),
    cov = purrr::map_dbl(data, function(dt) cov(dt$year, dt$lifeExp)),
    corr = purrr::map_dbl(data, function(dt) cor(dt$year, dt$lifeExp)),

    # add panel
    panel = map_plot(data, function(dt) {
      # display a line plot of X:year, Y:life expectancy
      ggplot(dt, aes(year, lifeExp)) +
        geom_smooth(method = "lm") +
        geom_line() +
        ylim(20, 85)
    })
  ) %>%
  # remove the condensed data
  select(-data) %>%
  print() ->
gap_trellis_plus

gap_trellis_plus %>%
  trelliscope("gapminder", nrow = 3, ncol = 5, path = "example/gapminder_plus")
@

The amount of work to retrieve information that can be readily seen or calculated from the visual display quickly increases.  At first, there were two values used.  Now there are six values used to explain just the $Y$ data and the $\left\{X,Y\right\}$ combination.  As the amount of layers increase, the number of cognostics needed to explain the plot layer will also increase.  Given each plotting panel already contains statistical information, it should be leveraged to generate cognostics automatically.

\subsection{Example}

Using the panel column only, we will derive many cognostics using the \autocogs R package.

<< autocogs_first >>=
gapminder %>%
  group_by(country, continent) %>%
  tidyr::nest() %>%
  mutate(
    panel = map_plot(data, function(dt) {
      # display a line plot of X:year, Y:life expectancy
      ggplot(dt, aes(year, lifeExp)) +
        geom_smooth(method = "lm") +
        geom_line() +
        ylim(20, 85)
    })
  ) %>%
  select(-data) %>% # remove the condensed data
  print() ->
gap_panel

gap_auto <- autocogs::add_panel_cogs(gap_panel)
gap_auto %>% print(width = 150)
@

For each panel, \rinline{2 + 19 + 5 + 5 + 2 + 5 = 38} cognostics were auto generated to aid in exploration of the panels.

  \begin{enumerate}
    \item Ten of the cognostics calculate information individual column information. (\rinline{_x}, \rinline{_y})
    \item Two cognostics calculate continuous bivariate metrics. (\rinline{_bivar})
    \item Five cognostics calculate metrics involving the number of points and their availbility. (\rinline{_n})
    \item Two cognostics calculate metrics for the smooth line added to each panel. (\rinline{_smooth})
    \item Nineteen cognostics are calculated for the linear model applied to the panel.  These metrics will be dicussed in greater detail later. (\rinline{_lm})
  \end{enumerate}

Each univariate grouping is labeled to provide context as to what is calculated and which variables were used.






\subsection{Framework}

\autocogs package was built to provide a consistent framework for calculating cognostics independent of the class of the plotting supplied.  Ideally, it should work for \ggplot, \pkg{rbokeh}, \pkg{plot.ly}, etc. and produce the same result for similar plot displayed in the different plotting packages.  Currently, only \ggplot hooks have been installed, but \pkg{rbokeh} and \pkg{plot.ly} can be added using the publically available functions in the \autocogs package.


By definition, each subset panel within trelliscopejs will contain the same plotting layers, only with different data.  Addressing each layer will produce the same group of output cognostics but with different values.  There is a ``one to many'' mapping from plot to plot layers and a ``one to many'' mapping from plot layers to cognostics.  These same final cognostics can be produced from many different layers.

\includegraphics[width = \textwidth ]{./dot/plot_layers.pdf}

Once all the cognostics have been produced for a given plot, they are reduced to keep only the unique cognostic name and value combinations.  Using the diagram above, the cognostic groups $\left\{A, B, ..., M\right\}$ will be returned once.

\subsection{Cognostic Groups}

Each set of cognostics is returned in a cognostic group.  This is similar to scagnostics.  Scagnostics all pertain to scatterplots.  Likewise, the number of non-NA X, non-NA Y, and non-NA X and Y points are pertain to non-NA counts of the displayed data.  These groups can be extended to each type of graphical display: box plot, histogram, linear model, etc.

The cognostics produced in the autocog gapminder example (TODO LINK TO EXAMPLE) were:
\begin{enumerate}
  \item \rinline{_smooth}: Two cognostics pertaining to a ``smooth'' line being added to the panel.
  \item \rinline{_lm}: Nineteen cognostics pertaining to the linear model line added to the panel.
  \item \rinline{_x, _y} Five cognostics pertaining only to the X and Y values respectively.
  \item \rinline{_bivar} Two cognostics pertaining only to both the X and Y values.
  \item \rinline{_n} Five cognostics pertaining only to counts of X and Y values.
\end{enumerate}

Each cognostic group column contains a single row data frame nested in each cell.  Nesting data structures is considered an advanced technique, but by nesting the cognostic data frames in each cell, \autocogs maintains the tidy data input with tidy data output.  Tidy data is defined to have variables in each column, observations for each row and each cell contains a value.  The value does not need to conform to atomic values but allows for complex structures as long as the ``tidy data'' rules are kept.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figs/tidy.png}
  \caption{Figure taken from \cite{r4ds}. ``Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells.'' (\cite{r4ds})}
\end{figure}





\subsection{}





For any data types
  Can be linear models, box plots, etc.
Example of gapminder linear model and $R^2$


Autocogs
  Framework
    Automatically create cognostics given a display object
      Inspect the plot object
      Determine which layers are displayed
      Apply cognostics per layer
      Collect unique cognostics
      Return result
    Existing base cognostic groups
      Short paragraph on each one
    Connect to plotting frameworks,
      Short paragraph (and example?) on each one
      Ggplot2 layers
        $Geom_point$
        $Geom_line$
        etc...


\subsection{Caluclations}






TODO keep writing




















Using the \rinline{gapminder} dataset as an example, we can explore the linear model trend of the life expectancy over time.

%\trelliscopejs has integrated functionality with \ggplot, so we will reduce the amount of code using the function \rinline{facet_trelliscope}.

<< all_info  >>=
gapminder_condensed %>%
  mutate(
    # add metrics
    min_lifeExp = purrr::map_dbl(data, function(dt) min(dt$lifeExp)),
    max_lifeExp = purrr::map_dbl(data, function(dt) max(dt$lifeExp)),
    # add panel
    panel = map_plot(data, function(dt) {
      # display a line plot of X:year, Y:life expectancy
      ggplot(dt, aes(year, lifeExp)) +
        geom_smooth(method = "lm") +
        geom_line() +
        ylim(20, 85)
    })
  ) %>%
  # remove the condensed data
  select(-data) %>%
  print() ->
gap_trellis

# display the plots and metrics in trelliscopejs
gap_trellis %>%
  trelliscope("gapminder", nrow = 3, ncol = 5, path = "example/gapminder")
@

<< lm_facet >>=
gapminder %>%
  ggplot(aes(year, lifeExp)) +
    geom_line() +
    geom_smooth(method = "lm") +
    facet_trelliscope(~ continent + country, nrow = 3, ncol = 5, path = "example/gapminder_facet")
@

Each panel contains a linear model that can be used to interpret each countries' life expectancy over time.  The linear model information contained within each panel is not calculated until \ggplot displays the plot.  Information within each model can be useful when sorting panels within trelliscopejs.  This




Future work
  Add cognostics for time series data
  Add safety layer for the execution (try catch)
  Add message similar to $facet_map$ to submit them to github
  Add rbokeh layer connections
  Add plotly layer connections
