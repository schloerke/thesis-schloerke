
% Extra cites
% https://en.wikipedia.org/wiki/Key-value_database
% https://en.wikipedia.org/wiki/Strong_and_weak_typing
% https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
% https://en.wikipedia.org/wiki/Application_programming_interface


Since 2012, Facebook has developed GraphQL: ``a query language for APIs and a runtime" \cite{graphql_org}.  GraphQL drastically reduces the number of server requests created by the browser by using a dynamic and nested query structure.  Using the Working Draft Specification for GraphQL \cite{graphql_spec} as guidance, \gqlr~\cite{r_gqlr}~implements a full GraphQL server within R.  \gqlr~allows users to supply their own R functions to satisfy the data requirements of a GraphQL query generated by the browser.  \gqlr~was originally built to communicate between \trelliscopejs~and an R server session.  However, \trelliscopejs's direction changed since the development of \gqlr.

% TODO keep last two lines of intro paragraph?


\section{Application protocol interfaces}

Application Protocol Interfaces (APIs) are the fundamental backbone of communication between machines.  They enable machines to communicate with each other without needing to know how the responding machine arrives at its answer.  There are two conventions for a machine API: simple API and custom API.  Each API style has their own advantages and disadvantages.  GraphQL was created to address the disadvantages of simple API while keeping the advantages of a custom API at the cost of typing the request.


There are two parts involved in each API communication: the request and response.  The request submits a query to the server, and the response returns an answer that should be able to be understood by the requesting entity.  The key point to the communication transaction is the request does not need to know how the response calculates the answer.

This layer of abstraction shields the request from knowing the nitty-gritty implementation details of the response.  This allows the response to behave like a black box that will only respond to particular requests or queries.


In this chapter, I will only address single response APIs as I am concerned with the request, not the response.  A single response API is an API that returns only one response to one answer.  I will not discuss streaming APIs in this chapter.

Throughout this section, I will use a calculator, `Calculator', as my example server.  The calculator will be have four internal functions: add, subtract, multiply, and divide.  These four internal functions behave just like a regular calculator, but the true implementation of the calculator is hidden.

\subsection{Simple API}

% There are two common styles of single response APIs: simple and custom response.
A simple API has a single end point, or place to send a request, for each style of question it knows how to answer.  A simple Calculator API would contain four end points: add, subtract, multiply, and divide.  Each query routine requires two numeric values as inputs and responds with a single numeric value.  To concisely define a RESTful Calculator, we may state the following schema:

\begin{graphqlcode}
# GraphQL; Schema
type Calculator {
  add(A: Float, B: Float): Float
  subtract(A: Float, B: Float): Float
  multiply(A: Float, B: Float): Float
  divide(A: Float, B: Float): Float
}
\end{graphqlcode}

\subsubsection{Advantages}

Without abstracting the function name, the number of request end points match the number of exposed functions.  There are no dynamically created functions; everything is static.  By fixing all request end points, software systems can be reliably built against one another.  Any software system can build their own logic as to how they solve their particular problems, but each software system will request from the same API.

The ease of use of a simple API has made it very popular with HTTP internet websites with the RESTful API \cite{rest_popular}.  The four most common functions of HTTP's REST are ``GET'', ``PUT'', ``POST'', and ``DELETE''.

\begin{enumerate}
  \item GET: Retrieve the supplied location data only.
  \item PUT: Store supplied data the supplied location.
  \item POST: Add new data at the supplied location.
  \item DELETE: Remove data at the supplied location.
\end{enumerate}


\subsubsection{Disadvantages}

As is common in practice, databases have many tables with built in relationships. RESTful APIs usually only return information one layer deep.

When looking at the Calculator, it solves a single calculation for each query.  To solve a multiple calculation problem, it takes multiple requests to the Calculator API.  For example, solving $1 + 2 + 3 + 4 + 5$ requires 4 requests to the Calculator API; one query for each of the $addition$ operations.

<< calc_add, eval = FALSE >>=
answer = Calculator::add(1, 2) # 3
answer = Calculator::add(answer, 3) # 6
answer = Calculator::add(answer, 4) # 10
answer = Calculator::add(answer, 5) # 15
@

No matter how the requests are altered, it will require 4 requests to the Calculator.  This can become a major disadvantage when required to make many, many requests to the API.  If we were to look at a person's friends of their friends, we would need the following Schema and data information:

\begin{graphqlcode}
# GraphQL; Schema
type Person {
  id: ID
  name: String
  age: Int
  sex: String
  friends: [ID]
}
\end{graphqlcode}

Each person has an ``id'', ``name'', ``age'', ``sex'', and a list of person id's for their ``friends''.  While having all of this information is useful, it can bloat the amount of information that is returned.  While the current example isn't too big, one could imagine adding a \graphqlinline{Person}'s favorite song lyrics to the \graphqlinline{Person} object.  This would greatly increase the total amount of information returned for each \graphqlinline{Person} object.

\subsection{REST and the Internet}

In the case of the internet, however, two major constraints exist.  The two major constraints are the number of parallel requests that can be made at one time and the amount of time it takes for your request to reach a responding server.

HTTP 1.1 specification states that ``A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy'' \cite{http_connections}.  In practice, this is a little larger, maxing out at 13 parallel connections to the same host \cite{browserscope}.  Limiting the number of server connections reduces the amount of simultaneous requests on the network and improves overall response time.

Once a request is allowed to be made, there are physical limitations on how fast the response can be received.  On average, it takes over 200 ms for a request to make a trip to the responding server and back to the user's browser \cite{internetweathermap}.

Using the ``friends of my friends'' example, let us define each person as having 200 different friends (the median number of friends on Facebook \cite{facebook_friends}.  When using a simple API, we can calculate how many requests are necessary to compute who are the ``friends of my friends''. It requires $O(n^2) (\sim 200^2 = 40,000)$ independent requests to the simple API server.  If the browser being used is limited to 10 parallel connections, it requires $4000 (= 40,000 / 10)$ sets of parallel request groups.  Each parallel request group takes at least 200ms for a round trip to and from the server.  The total amount of time it would require to gather the names of a person's friends of friends would take $13 \frac{1}{3} minutes = \dfrac{(200 requests)^2}{10 requests} * \dfrac{0.200 \frac{seconds}{request}}{60 \frac{seconds}{minute}}$.

The median loading time for a website is about 3 seconds with the average around 5 seconds \cite{website_speed}.  Major websites today try to shave milliseconds where ever they can.  No major website would allow a load time that is 160 times slower than the average website.

% With the average website is now requiring more than 100 requests per page (http://www.websiteoptimization.com/speed/tweak/average-number-web-objects/), website turn around is decreasing.


\subsection{Custom response}

A natural response to the Friends of Friends situation above is, ``Why not make a custom response?'' A custom API answers this specific question.

\subsubsection{Advantages}

Because a custom API answers specific questions, only one request to the server needs to be made.  The ``friends of my friends'' example is reduced to a single 200 ms request.  The load time is now reduced from 800 seconds to 0.2 seconds.  This answers the ``who are my friends of my friends''question in the minimal amount of queries to the server.  The custom API achieves the end goal answer with the minimal amount of queries to the server.

\subsubsection{Disadvantages}

The disadvantages come from the amount of engineering time that is required to implement a custom response for every query need.  With a simple query interface, the logic is put on the user who is querying to figure out what to query next.  With a custom response interface, all custom responses must be made before the user can utilize them.

Using the Calculator example, calculating the $1 + 2 + 3 + 4 + 5$ example could be done in a single custom request called ``1add2add3add4add5''.  It would solve the answer in a single request, but the server would have to implement many, many responses for full funtionality of a true Calculator.

With the internet, the custom API response is now tied directly to the requesting website.  This creates little separation between the website and the responding API server.  By coupling the data server with the requesting service, developments in the requests are slower and more difficult than if a de-coupled, simple API is used.  Websites making the requests can not move ahead in development until a new custom response has been enabled by the custom API server.

\subsection{Balancing act}

Let's recap the advantages and disadvantages of the two different styles of APIs.

\begin{enumerate}
  \item Simple API
    \begin{enumerate}
      \item Advantages
        \begin{enumerate}
          \item Small API
          \item Easier to implement
        \end{enumerate}
      \item Disadvantages
      \begin{enumerate}
        \item Many queries are required to solve complex problems
        \item Many queries causes large time complexity
        \item Every piece of information is returned for every query
      \end{enumerate}
    \end{enumerate}
  \item Custom Responses
    \begin{enumerate}
      \item Advantages
        \begin{enumerate}
          \item One query, one answer
          \item Fast execution time
        \end{enumerate}
      \item Disadvantages
        \begin{enumerate}
          \item All custom API calls need to be implemented
          \item API server is tied to the requests made
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

% It is a balancing act to use a simple API, which causes more requests, and a

Developers balance between minimal engineering time and minimal execution time.  Typically the final result falls somewhere in-between, using a custom API for high execution time queries and using a simple API for smaller queries.



% \section{Variable typing}
%
% Programing languages know the type of objects in two ways: strong typed and weakly typed.  Strong typed languages know ``whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function.'' \cite{Liskov74programmingwith}.  Weakly typed languages allow a programmer to passively use a invalid type as if it was correct.  Using Javascript, we can define a function that returns the square of an object's key $key$. The function does not define any requirements about the variable $x$.  The \emph{hope} is that the function will only be called with a valid object type.
%  % \cite{crockford2008javascript}.
%
% \begin{jscode}
% // javascript
% square_key = function(x) {
%   return x.key * x.key;
% }
% square_key({key: 5})
% // 25
% square_key(5)
% // NaN
% \end{jscode}
%
% In a strong typed C++ example, an integer is not cast into a \cppinline{KeyVal} object. By requiring variable types for inputs and outputs, the variable class is known at compile time and the program may be checked for type errors.
%
% \begin{cppcode}
% // C++
% struct KeyVal {
%   double key;
% };
% double square_key(KeyVal x) {
%   return x.key * x.key;
% };
% int main() {
%   KeyVal x;
%   x.key = 5;
%   std::cout << square_key(x); // Would print "25"
%   std::cout << square_key(5); // Causes compile error
% }
% // In function 'int main()':
% // 12:26: error: could not convert '5' from 'int' to 'KeyVal'
% \end{cppcode}

% TODO is this database section needed?

\section{Database storage}

Once a request is received by an API, the API must retrieve the data from a database.  Databases can store objects in one of two common paradigms: as a relational database or as a key-value database.  Relational databases know exactly what kind of object will be returned and can map one table to another with id values.  Key-value databases, on the other hand, do not inspect the values of the database.  The requirement for a key-value database is that each value is stored at a specific key.  Key-value databases are built for speed and scalability over structure and relationships.

While relational databases are already inherently typed (unless purposely stated as an unknown type), well designed key-value databases inherently contain typed values.  Each value that is inserted into the database has a known shape and expected response type.  If data of an image is stored, audio data should never be returned from that same position.  Even if the image had different sizes and formats, it still can be understood as an image.

There are many more comparisons and cost / benefits to every database, however these implementation differences are not apart of the scope of this chapter.



\section{GraphQL language}

GraphQL is a data query language built to unify data APIs.  It exists as a execution layer between the requesting user and responding database.  This abstraction layer provides many benefits: uniform request and response shape, dynamic queries to handle custom situations, and minimal server requests.

GraphQL is comprised of two main parts, the Request and the Schema.

\subsection{Schema}

GraphQL Schemas are defined using Scalars, Types, Enumerations, Lists, Non-Null types, Interfaces, Unions, and Input types.  Each definition is used to define a type or type abstractions that can be used when querying.  The Types represent the expected return objects that the database already knows about from the Schema definition.  Like most objects, each Object Type will contain fields that point to Scalars or more Types.  These Object fields can be queried recursively until a Scalar or Enumeration is reached.

\subsubsection{Object type definition}

For example, we can setup a Schema for a pet dog.

\begin{graphqlcode}
type Dog {
  name: String
  breed: String!
  owners: [Person!]!
}
\end{graphqlcode}

The type definition for a \graphqlinline{Dog} above is very readable, but has a lot going on.

\begin{enumerate}
  \item \graphqlinline{Dog} is a Object Type definition.  It has four fields:  \graphqlinline{name}, \graphqlinline{breed}, \graphqlinline{age}, and \graphqlinline{owners}.  These four fields are the only fields defined for retrieving information from a \graphqlinline{Dog}.
  \item \graphqlinline{String} is a predefined Scalar type definition.  This contains the dog's name, i.e. ``Clifford''.  Scalar fields do not contain any sub fields and are considered leafs in the Schema definition tree. Leafs do not contain sub fields for further information retrieval.
  \item \graphqlinline{String!} represents a Non-null String value.  This means that all \graphqlinline{Dog} objects will contain the \graphqlinline{breed} field and the result will always be a String.
  \item \graphqlinline{[Person]} represents an array of Person objects that represent the owners of the Dog. By adding the \graphqlinline{!} outside the array to form \graphqlinline{[Person]!}, it will be guaranteed to return an array for the field \graphqlinline{owners} and never a \graphqlinline{NULL} value.  By adding a \graphqlinline{!} to the Person (\graphqlinline{[ Person!]!}), the elements inside the position array will never be \graphqlinline{NULL}.  A length $0$ array is still allowed as the \graphqlinline{owners} value is not \graphqlinline{NULL} and the missing \graphqlinline{Person} values are not \graphqlinline{NULL}.
\end{enumerate}


\subsection{Argument and input type definitions}

Field definitions can include arguments.  These arguments can be simple Scalar definitions or Input Type definitions.

\begin{graphqlcode}
# GraphQL; Schema
input ToyInput {
  brand: String
  name: String
  condition: Condition
}
extend type Dog {
  weight(unit: WeightUnit = POUNDS): Float
  does_play_with_toy(toy: ToyInput): Boolean
}
\end{graphqlcode}

Like the R language, all arguments are named arguments, all arguments may be submitted in any order, and default values may be provided.  Unlike R, all submitted arguments must have a name and must comply with the argument type.  Nothing is inferred from the arugment's position.  Default values may be used in place of missing arguments.

\subsection{Schema type definition}

There are two entry points to a Schema: schema query type and schema mutation type. Every GraphQL Schema definition must have a schema query type and can optionally have a schema mutation type.  Both types refer to an object type definition.

\begin{graphqlcode}
# GraphQL; Schema
schema {
  query: Dog
  mutation: DogUpdate
}
\end{graphqlcode}

Query types are read only, while mutation types are understood that something will update in the database.  A request will have the same shape for both query types and mutation types.

\subsection{Scalar type definitions}

Scalar Types are the leafs of the Schema.  Unlike Object Types, Scalars do not have fields to inspect.  GraphQL defines the base scalars as a part of the language definition:

\begin{enumerate}
  \item \graphqlinline{Boolean}: $true$ or $false$
  \item \graphqlinline{Integer}: A signed 32-bit integer
  \item \graphqlinline{Float}: A signed double-precision floating point value
  \item \graphqlinline{String}: A UTF-8 character sequence
  \item \graphqlinline{ID}: \graphqlinline{ID} performs the same as a \graphqlinline{String}, but it is intended to be machine readable only as a unique identifier
\end{enumerate}

New scalars can be defined in a Schema as long as the server running the GraphQL runtime understands how to handle them.  Three new Scalars are defined below.

\begin{graphqlcode}
# GraphQL; Schema
scalar Date
scalar Binary
scalar Hexadecimal
\end{graphqlcode}



\subsection{Enumeration type definitions}

GraphQL understands a finite category variable.  This is similar to a \rinline{factor} in R.  There is a fixed set of values for every Enum definition.  Internally in the GraphQL server, Enum definitions may be stored as Integer values or as an object similar to a Set, but in the GraphQL language, it will be represented as a string with all capitol letters, such as \graphqlinline{POUNDS}.

\begin{graphqlcode}
# GraphQL; Schema
enum WeightUnit {
  POUNDS
  KILOS
  OUNCES
}
\end{graphqlcode}

Whenever a \graphqlinline{WeightUnit} type is expected, only the values of \graphqlinline{POUNDS}, \graphqlinline{KILOS}, or \graphqlinline{OUNCES} may be used.  While R supports \rinline{factor} values, and full Enumeration class is created in the \gqlr~R package.


\subsection{Interface type definition}

Interfaces are an integral part in abstracting pieces of types of objects.  They allow for common fields to be accessed on objects without knowing the true type of the object.  All Object Types that inherit an interface must implement all fields of that interface.  Any Object Type that implements \graphqlinline{Pet}, must implement the two fields \graphqlinline{name} and \graphqlinline{owners} and return \graphqlinline{String} and \graphqlinline{[Person!]!} respectively.

\begin{graphqlcode}
# GraphQL; Schema
interface Pet {
  name: String
  owners: [Person!]!
}
type Dog implements Pet {
  name: String
  barkVolume: Int
  owners: [Person!]!
}
type Cat implements Pet {
  name: String
  meowVolume: Int
  owners: [Person!]!
}
\end{graphqlcode}

An Object Type may implement extra fields, like \graphqlinline{meowVolume} in \graphqlinline{Cat}.

Interfaces are useful when queries are made on objects where the exact return type is not known, but a finite set of types exist for the expected value.

\begin{graphqlcode}
# GraphQL; Schema
extend type Person {
  pet: [Pet!]! # returns an array of Cat or Dog types
}
\end{graphqlcode}

Object definitions may interface with many Interface definitions.

\subsection{Union type definition}

Unions contain a finite set of Object Types but do not specify common fields.  Unions are not allowed to contain other unions or interfaces.  \graphqlinline{NotAPlant} results being returned could either be a \graphqlinline{Person}, \graphqlinline{Dog}, or \graphqlinline{Cat} type.

\begin{graphqlcode}
# GraphQL; Schema
extend type Cat {
  weight(unit: WeightUnit = KILOS): Float
}
union NotAPlant = Person | Dog | Cat
\end{graphqlcode}


\section{Requests}

The following Schema will be used within the Requests section.  Classic Disney characters will be used as the data.

\begin{graphqlcode}
# GraphQL; Schema
scalar Date
enum WeightUnit {
  POUNDS
  KILOS
  OUNCES
}
type Person {
  name: String!
  weight(unit: WeightUnit = POUNDS): Float
  friends: [Person!]!
  pets: [Pet!]!
}
\end{graphqlcode}
\begin{graphqlcode}
interface Pet {
  name: String
  born: Date
  owners: [Person!]!
}
type Dog implements Pet {
  name: String
  barkVolume: String
  born: Date
  owners: [Person!]!
}
type Cat implements Pet {
  name: String
  born: Date
  meowVolume: String
  owners: [Person!]!
}
union SearchResult = Person | Dog | Cat
\end{graphqlcode}
\begin{graphqlcode}
type QueryType {
  search_name(name: String!): SearchResult
  person(name: String! = "Mickey Mouse"): Person
  dog(name: String! = "Pluto"): Dog
  cat(name: String! = "Figaro"): Cat
}
type MutationType {
  addToWealth(name: String!, amount: Float): Float
}
schema {
  query: QueryType
  mutation: MutationType
}
\end{graphqlcode}


\subsection{Queries}

Every object in the Schema definition can be queried.  A query on an object type must include at least one field.  Object Types are not considered leafs in the Schema definition tree as they are guaranteed to have at least one field.

\begin{graphqlcode}
# GraphQL; Query
{
  person {
    name
  }
}
\end{graphqlcode}
\begin{jscode}
// JSON; GraphQL Response
{
  "data":{
    "person": {
      "name": "Mickey Mouse"
    }}}
\end{jscode}

Queries have the same shape has the result.  The only difference occurs when a result is an array of information.  Using an \graphqlinline{name} argument below, we can look at Jim Dear's pets from the movie ``Lady and the Tramp'' \cite{jimdear}.

\begin{graphqlcode}
# GraphQL; Query
{
  person(name: "Jim Dear") {
    name
    pets {
      name
    }}}
\end{graphqlcode}
\begin{jscode}
// JSON; GraphQL Response
{
  "data":{
    "person": {
      "name": "Jim Dear",
      "pets": [
        { "name": "Lady" },
        { "name": "Tramp" }
      ]}}}
\end{jscode}


The whole query string is submitted to the GraphQL server.  This allows for complex and deeply nested queries in a single request.  Using the query below, we can query for all pets owned by the same owners as Duchess the cat \cite{madame}.

\begin{graphqlcode}
# GraphQL; Query
{
  cat(name: "Duchess") {
    owners {
      name
      pets {
        name
      }}}}
\end{graphqlcode}
\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "cat": {
      "owners": [{
        "name": "Madame Adelaide Bonfamille",
        "pets": [
          {"name": "Duchess"},
          {"name": "Marie"},
          {"name": "Berlioz"},
          {"name": "Toulouse"},
          {"name": "Thomas O'Malley"}
        ]}]}}}
\end{jscode}

Normally the code above would require $O(k * n)$ requests in a simple API, with $k$ owners and $n$ pets belonging to each owner.  With GraphQL, this query is resolved in one request and without the need for a custom API to be built.  The single GraphQL query needed for the ``friends of my friends'' example is shown below.

\begin{graphqlcode}
# GraphQL; Query
{
  person(name: "Barret") {
    friends {
      name
      friends {
        name
      }}}}
\end{graphqlcode}






\subsubsection{Aliases}

Aliases can be used to query the same object field multiple times.


\begin{graphqlcode}
# GraphQL; Query
{
  duchess: cat(name: "Duchess") {
    name
    meowVolume
  }
  rajah: cat(name: "Rajah") {
    name
    meowVolume
  }}
\end{graphqlcode}

\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "duchess": {
      "name": "Duchess",
      "meowVolume": 2
    },
    "rajah": {
      "name": "Rajah",
      "meowVolume": 9
    }}}
\end{jscode}

% \end{tabular}


\subsubsection{Fragments}

For conciseness, the query above can be made using Fragments.  Fragments can be used when repeated fields are called on similar objects.

The same result will occur using the Fragments below.

\begin{graphqlcode}
# GraphQL; Query
{
  duchess: cat(name: "Duchess") {
    ...catFields
  }
  rajah: cat(name: "Rajah") {
    ...catFields
  }
}
fragment catFields on Cat {
  name
  meowVolume
}
\end{graphqlcode}
\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "duchess": {
      "name": "Duchess",
      "meowVolume": 2
    },
    "rajah": {
      "name": "Rajah",
      "meowVolume": 9
    }}}
\end{jscode}

Fragments are very useful in breaking down complex queries into smaller sections.

\subsection{Mutation}

Mutations are the ``write'' to a database.  Mutations also return information to avoid an immediate ``read'' afterwards.  While there is no guarentee that a Query does not alter the database, it is a good practice to distinguish which commands read only and which commands write to the database. The mutation example below adds to the wealth of Scrooge McDuck \cite{scrooge}.

\begin{graphqlcode}
# GraphQL; Schema
type MutationType {
  # returns total wealth after adding amount
  addToWealth(name: String!, amount: Float): Float
}
\end{graphqlcode}
\begin{graphqlcode}
# GraphQL; Mutation
mutation {
  addToWealth(name = "Scrooge", amount = 1000.0)
}
\end{graphqlcode}
\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "addToWealth": 28800000
  }}
\end{jscode}


\subsection{Remaining GraphQL language}

There are many more intricacies in the GraphQL language that are not in the scope of this paper.



\section{\gqlr: GraphQL R server implementation}

\gqlr~is an R package that implements the GraphQL server specification.  \gqlr~handles Query and Mutation Requests and returns data in the proper format.  It is built upon the next evolution of class definitions in R, \pkg{R6} \cite{r_r6}.

\subsection{\pkg{R6}}

\pkg{R6}~is a lightweight R package that creates objects that do not follow the particular conventions of R.  R known for being ``pass by value'' language. This means that all values are copied at the beginning of a function. Like many other languages, R does not have dynamic values for a list object.  Values placed in a list in R stay as the same values.

<< pass_by_value >>=
my_list <- list(A = TRUE, B = FALSE)
my_list$A
update_A_to_false <- function(x) {
  x$A <- FALSE
  x
}
update_A_to_false(my_list)
my_list
@

The example above does not update the value of A to \rinline{FALSE} as the value \rinline{my_list} was copied at the beginning of the function \rinline{update_A_to_false}.

\pkg{R6}~allows for objects to be altered inside functions that they have been passed to without any changes in assignment method.  This is similar to a ``pass by reference'' coding paradigm.  An \pkg{R6}~object is passed to a function and the function alters the value.  The same \pkg{R6}~object outside of the function is altered as well.  This is not expected R behavior.

\pkg{R6}~is built upon the use of Classes.  \pkg{R6} classes are similar to Javascript's ES6 classes.  There is a constructor, methods, and values for each class.  The methods and values can be both private (only able to be seen internally) and public (available to anything).  Like Javascript, there is a notion of the ``this'' value or an object representing itself.  \pkg{R6}~uses the \rinline{self} object in this case.  Internal object values are retrieved using \rinline{value <- self\$key}.  The example below defines a new object \rinline{barret} with the name of \rinline{"Barret"}.  Unlike regular R behavior, the name is changed globally to \rinline{"Schloerke"} by calling the function \rinline{update_name_to_schloerke}.

<< library_r6, echo = FALSE, cache = FALSE >>=
library(R6)
library(gqlr)
library(magrittr)
@

<< gqlr_minimal >>=
Minimal <- R6Class("Minimal",
  public = list(
    name = NULL,
    initialize = function(name = NA) {
      self$name <- name
      self$greet()
    },
    greet = function() {
      cat(paste0("Hello, my name is ", self$name, ".\n"))
    }
  )
)
barret <- Minimal$new("Barret")
barret$name
update_name_to_schloerke <- function(x) {
  x$name <- "Schloerke"
  invisible(x)
}
update_name_to_schloerke(barret)
barret$name
@


\pkg{R6}~also allows for dynamic queries.  \pkg{R6}~calls these ``active fields''.  These fields are actually function calls, but appear a regular keys in the object.  The active key function can handle a single argument.  This argument represents the value of the object being stored.  If no value was supplied, then the active key was retrieved, not set.

In the example below, a single active key of $random$ will return a uniform value when retrieved and will set the random seed if the $random$ key is set.  After the key is set to $1234$, as expected, the same random values are returned.

<< gqlr_minimal_active >>=
MinimalActive <- R6Class("MinimalActive",
  active = list(
    random = function(x) {
      if (missing(x)) {
        return(runif(1))
      }
      set.seed(x)
      TRUE
    }
  )
)
min_active <- MinimalActive$new()
min_active$random
min_active$random
min_active$random <- 1234
min_active$random
min_active$random
min_active$random <- 1234
min_active$random # same value as the first random value with seed 1234
@

Finally, \pkg{R6}~allows for inheritance.  In the GraphQL's abstract syntax tree, many objects inherit from one another in a directed, acyclic graph structure.  \pkg{R6}'s class inheritance extends nicely to the abstract syntax tree requirments of GraphQL.

<< gqlr_inheritance >>=
ParentClass <- R6Class("ParentClass")
ChildClass <- R6Class("ChildClass", inherit = ParentClass)
child <- ChildClass$new()
class(child)
inherits(child, "ParentClass")
@

In \gqlr, all active values must inherit the correct class to be allowed to set.  An Error will be thrown if a value does not contain the proper inheritance.  The example below shows the creation of a named type ``Dog''.  It also shows an attempt at setting the $name$ value to a character.  This is not allowed as the $name$ value only allows objects that inherit the class ``Name''.

<< named_type_dog >>=
(obj <- gqlr:::NamedType$new(name = gqlr:::Name$new(value = "Dog")))
str(obj$name)
obj$name <- "Dog"
@

\gqlr~uses these active fields to accomplish typed language properties while executing in a untyped language of R.  While enforcing typing within R does not happen often, it is required for GraphQL to be implemented.

\subsection{Execution}

At first glance, R and GraphQL seem like an unlikely combination.  R is an untyped (dynamically typed) language while GraphQL is a typed language.  R is not known for its raw speed and one of GraphQL's goals is to reduce execution time.

However, R is known for its statistical models, statistical graphics, and its very fast iteration speed \cite{r_about}.  \gqlr~is built to help small projects provide proof of concepts and for developers to mock full backend systems locally.  Being able to submit the same style of request string for the production server and local development increases the productivity of the web development cycle.

The example below creates a model schema that creates a linear model and a loess model.  Both models return the mean squared error (\rinline{mse}) for their respective models.  The linear model also returns a GGally's ggnostic plot which is data64 encoded for data portability.  The loess model also returns the effective number of parameters (\rinline{enp}).

<< setup_execute >>=

"# GraphQL; Schema
scalar ImageData64
type LinearModel { mse: Float!, ggnostic: ImageData64! }
type LoessModel { mse: Float!, enp: Float! }
type Model {
  linear(formula: String, data_name: String): LinearModel
  loess(formula: String, data_name: String): LoessModel
}
schema { query: Model }
" %>%
  gqlr::gqlr_schema(
    ImageData64 = function(p, schema) {
      tmp_file <- tempfile(fileext = ".png")
      on.exit(unlink(tmp_file))
      ggplot2::ggsave(tmp_file, p)
      knitr::image_uri(tmp_file) %>%
        substr(start = 1, stop = 40) %>%
        paste0("...")
    },
    LinearModel = function(model, schema) {
      list(
        mse = mean(model$residuals ^ 2),
        ggnostic = function(...) {
          GGally::ggnostic(model)
        })},
    LoessModel = function(model, schema) {
      list(
        mse = mean(model$residuals ^ 2),
        enp = model$enp
      )},
    Model = function(ignore, schema) {
      model_ <- function(fn_) {
        function(null, args, schema) {
          formula_ <- as.formula(args$formula)
          data_ <- eval(as.symbol(args$data_name))
          fn_(formula_, data = data_)
        }}
      list(
        linear = model_(stats::lm),
        loess = model_(stats::loess)
      )}) ->
model_schema

@

In about 40 lines of code, a schema definition and execution methods can be implemented.  To build a strong typed API and its corresponding implementation in less than 100 lines is not an easy task.  With \gqlr, we are able to do it in less than half the lines of code.

In the implementation, four major R packages are called.

\begin{enumerate}
  \item \pkg{stats}~is used for the linear model function and loess function.
  \item \GGally~is used to call its model diagnostic plot matrix, \rinline{ggnostic}.
  \item \ggplot~is used to save the plot objected created by \GGally.
  \item \pkg{knitr}~is used for its ability to data64 encode images saved by \ggplot.
\end{enumerate}

These packages are built upon many other R packages and displays the extensibility of a schema execution.

To see the Model schema in action, we can execute a request using the classic R data set ``iris''.

<< execute_graphql >>=
'# GraphQL; Query
{
  linear(
    formula: "Petal.Length ~ Petal.Width",
    data_name: "iris"
  ) {
    mse,
    ggnostic
  }
  loess(
    formula: "Petal.Length ~ Petal.Width",
    data_name: "iris"
  ) {
    mse,
    enp
  }
}' %>%
  gqlr::execute_request(schema = model_schema) ->
result
@

<< print_result >>=
result
@

While R users might not find the query and output very compelling (as they can be done in a regular R session), it is good to remember that any web service with access to the Model Schema above can execute a similar command and get an answer that is executed by R.  During the request execution, \emph{any} R package can be used.  Being able to open the flood gates to R's extensive package list is very powerful. This allows Javascript in the browser and Python programs to retrieve full R plots and R model outputs using the same GraphQL API.

This schema can also be executed in a local GraphQL server session or on a production GraphQL server.  Both the local and production servers have the same schema, so each service will return the same shapes.  Each querying programming language will have the same query string and receive the same shaped response.


% TODO include this section?
\subsection{Web service}

A simple web server is included in \gqlr, but extending the web server to other url routes and authentication services are not included.  \gqlr~was built to handle GraphQL requests and leave the url routing and authentication to better suited packages.  While some may argue for a single, go-to R package, there are many existing URL request handlers and authenticators existing for R.




\section{Summary}

  \gqlr~leverages the GraphQL language to effectively and efficiently communicate custom defined queries to and from the server.  \gqlr~provides users the ability to rapidly iterate in a local R environment to mock large production-scale data backends.  Combining R's fast iteration speed with R's ability to connect to many different existing backend services saves developers time and effort while keeping the data API communication consistent.

  % TODO add more?





% There is a unique API or interaction method to query every database.  When making a database call to a MySQL server, there is a known SQL syntax for interacting with the relational database.  When making a database call to a MongoDB server, there is a different, known syntax for interacting with the NoSQL database.  For every known database, there is a unique language created to interact with the data.  If a database needs to be updated to a different database or is even upgraded to a new version, the query syntax, more often than not, is broken.  This leads to continuous integration with the query syntax and the database and constant reprogramming of the query syntax for every update of the database syntax.  GraphQL addresses this issue.
