


\chapter{\ggplot}



<< setup_tips, echo = FALSE >>=
library(GGally)
library(ggplot2)
library(dplyr)
tips <- reshape::tips %>%
  mutate(
    day = factor(as.character(day), levels = c("Thur", "Fri", "Sat", "Sun")),
    time = factor(as.character(time), levels = c("Lunch", "Dinner"))
  )
@



\section{ggplot2}

  % \ggplot is different from the standard visualization graphics in that
  %
  %

  % \subsection{The Grammar of Graphics}

  % \emph{The Grammar of Graphics} \cite{WilkinsonLeland2005TGoG} by Dr. Leland Wilkinson was originally released in 1999 and updated in 2005.  In his book, he ``presents a unique foundation for producing almost every quantitative graphic'' (\cite{WilkinsonLeland2005TGoG}).  Dr. Wilkinson's graphical foundation helped give book is used at the core philosophy of ggplot2 with


% Grammar of graphics
%   By Leland Wilkinson in 1999 and 2005
%   ``This book was written for statisticians, computer scientists, geographers, research and applied scientists, and others interested in visualizing data. It presents a unique foundation for producing almost every quantitative graphic found in scientific journals, newspapers, statistical packages, and data visualization systems. This foundation was designed for a distributed computing environment (Internet, Intranet, client-server), with special attention given to conserving computer code and system resources.''





\subsection{Layered Grammer of Graphics}

\ggplot, a data visualization R package, is based on a \emph{Layered Grammar of Graphics} (\cite{layered_grammar}).  During Dr. Wickham's studies at Iowa State University, he statistically consulted with many students and professors on how to produce visualizations for their studies. Dr. Wickham noticed many clients had trouble producing plots quickly and difficulty understanding how the plot was made.  This provided plenty of motivation to produce \ggplot, basing it on \emph{The Grammar of Graphics}.

\subsection{\ggplot Layer}

Many of the common statistical graphics are a single layered plot.  A scatter plot is made of a point layer and a boxplot as a boxplot layer.  There is no formal name for the data graphic where horizontally jittered points are displayed on top of a vertical boxplot.  Each layer is understood as a component to the plot, therefore the plot as a whole can be understood.  Wickham did state that while a layered grammar guides a well formed graphic \cite{layered_grammar}, he analogizes ``good grammar is just the first step in creating a good sentence'' \cite{layered_grammar}.

Each plot consists of three components: the data, geom, and scales. Respectively, each of the component defines what is being displayed, how it is displayed and where it is being displayed.  By infering from the supplied data source and geom defaults, many plots can be displayed without much coding.

<< geom_point >>=
p <- ggplot(tips, aes(total_bill, tip)) +
  geom_point()
p
@

Typically, each layer of the plot uses the same original data source to help better explore the data frame.  Multi-layered plots may use multiple data sources where it would not be appriate to combine data sources.  Added data sources are usally display contextual information, such as a map, or summary statistics, such as a mean or linear model.

<< tip_lm >>=
tip_lm <- broom::tidy(lm(tip ~ total_bill, data = tips))$estimate
(tip_lm_dt <- data.frame(
  intercept = tip_lm[1],
  slope = tip_lm[2]
))
p +
  geom_abline(
    data = tip_lm_dt,
    aes(slope = slope, intercept = intercept)
  )
@



% What is a layered plot


% Each layer allows for default argument values to be used instead of being supplied in every layer.  With decent default values, every argument does not need to be supplied as is described in Grammar of Graphics.

\subsection{Plot Creation}

All plot layers do not need to exist at the time of plot object inception.  Each layer of a \ggplot plot may be added one by one to the original plot object at different times of the code execution.  The simplist of plot objects consists of a default dataset and a default set of aesthetics.

<< minimal_gg >>=
minimal_plot <- ggplot(data = tips, aes(total_bill, tip))
# display delayed until print time
minimal_plot
@

No layers are displayed as none have been provided.  However, the scales have been infered from the default data and aesthetics.

\subsection{Comparison}

Building the plot up layer by layer and storing it as an R object until printed does not follow existing patterns in R graphics.  The R core package \pkg{graphics} (CITE) displays information in a plot immediately upon function call.  There is no ability to delay the display of the plot after the initial plot has been created with the \pkg{graphics} package.

<< graphics_plot >>=
g <- graphics::plot(tip ~ total_bill, data = tips)
# nothing is stored, as plot is already displayed
g
@

\pkg{lattice} graphics meets in between \ggplot and \pkg{graphics} as all layers must be supplied at plot creation, but the plot is not displayed until print time.  The prior two \ggplot examples, (CITE) and (CITE), both displayed the ability to delay the printing of the \ggplot plot object.  \pkg{lattice} graphics can also delay the display of the plot object as both \pkg{lattice} and \ggplot convert their plot objects to be displayed using the \pkg{grid} package at print time.  The \pkg{grid} package does not implement full statistical plots, but rather it implements a R plotting framework to be used by other packages like \ggplot and \pkg{lattice}.

<< lattice_xyplot >>=
l <- lattice::xyplot(tip ~ total_bill, data = tips)
# display plot
l
@

Finally after executing the \pkg{graphics} and \pkg{lattice} code above, we can add a point layer to the minimal \ggplot plot example.

<< minimal_point >>=
# layer added after plot inception
minimal_points <- minimal_plot + geom_point()
# displays plot
minimal_points
@

Modularization of the \ggplot code allows for customization of each layer added to the plot. This leads to a smaller, more consistent interface with each layer function.



\section{Facets}

% This is very important
%   ggplot2 does not create new columns of information
%     only performs minimal, common statistical transformations on existing columns such as binning and density
%   ggplot2 does not divide the data up in `cut' formats that do not exist in input data
%     only divides data (facets) according to pre-existing column combinations


Winston Chang, maintainer of ggplot2, explains facet'ing as ``[ploting] subsets of data into separate panels'' \cite{chang2013rgc}.  This is achieved using existing conditioning variables in the supplied data set. Each panel produces similar plots.  This technique commonly refered to as small multiples (CITE).  The same plots are displayed, but each plot contains an independent subset of the data.  Typically, only one or two conditioning variables are used, but any number of variables may be used when faceting a \ggplot plot.

Facets are useful when looking at the interaction with the conditioning variables.  Once all existing combinations of the conditioning variables have been made, subsets of the data are displayed in each of the panels with the strip (panel label) of the panel displaying the conditioning variable information.  Missing combinations can either be dropped or display an empty panel.  Facet wrap will drop missing combinations by default and facet grid will display an empty panel for missing combinations.  In ggplot2, all variables are considered discrete when used as faceting conditioning variables.



\subsection{Facet Wrap}

There are two types of faceting in \ggplot: facet wrap and facet grid.  Facet wrap displays each panel row by row from left to right then top to bottom.  The number of rows and/or columns can be specified to ease the guessing work made by ggplot2.  If no facet row or column counts are supplied, \ggplot attempts to give each uses \pkg{grDevices} algorithm, \rinline{n2mfrow(n)}, to determine a sensible number of rows and columns.  Plots are display starting in the top row, from left to right, working towards the bottom of the plotting area.


<< facets >>=
# p <- ggplot(iris, aes(Petal.Length, Petal.Width)) + geom_point()
# p + labs(title = "Iris Petal Length vs Width")
# p + facet_wrap(~ Species) + labs(title = "Iris Petal Length vs Width per Species")
p <- ggplot(tips, aes(total_bill, tip)) + geom_point()
p +
  labs(title = "No Facets")
p +
  facet_wrap(~ day, labeller = label_both) +
  labs(title = "Facet Wrap (~ day)")
p +
  facet_wrap(~ day + time, labeller = label_both) +
  labs(title = "Facet Wrap (~ day + time)")
@

\subsection{Facet Grid}

Facet grid forces a two dimensional layout when faceting a plot.  The layout involves two sets of conditioning variables: the X conditioning and the Y conditioning variables.  These two sets of conditioning variables pre-determine how many rows (Y) and columns (X) are produced.

<< facet_grid_example >>=
p +
  facet_grid(time ~ day, labeller = label_both) +
  labs(title = "Facet Grid (time ~ day)")
@

The plot above displays \rinline{time} on the rows ($y$) and \rinline{day} on the columns ($x$).  The \rinline{facet_grid} formula follows a typical linear model formula of \rinline{y ~ x}.  Multiple columns can be used in either the $x$ position or the $y$ position.  This allows the user the dipslay a set column combinations against another set of column combinations.

<< facet_grid_multi >>=
p +
  geom_smooth(method = lm, se = FALSE) +
  facet_grid(sex + smoker ~ time + day, labeller = label_both)
@

The plot above displays that both Male and Female smokers on Sunday Dinner do not follow a positive linear trend.








% a
