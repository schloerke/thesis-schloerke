




<< setup_tips, echo = FALSE, cache = FALSE >>=
library(ggplot2)
library(GGally)
library(dplyr)
tips <- reshape::tips %>%
  mutate(
    day = factor(as.character(day), levels = c("Thur", "Fri", "Sat", "Sun")),
    time = factor(as.character(time), levels = c("Lunch", "Dinner"))
  )
@



\section{\ggplot}

  % \ggplot~is different from the standard visualization graphics in that
  %
  %

  % \subsection{The Grammar of Graphics}

  % \emph{The Grammar of Graphics} \cite{WilkinsonLeland2005TGoG} by Dr. Leland Wilkinson was originally released in 1999 and updated in 2005.  In his book, he ``presents a unique foundation for producing almost every quantitative graphic'' (\cite{WilkinsonLeland2005TGoG}).  Dr. Wilkinson's graphical foundation helped give book is used at the core philosophy of \ggplot~with


% Grammar of graphics
%   By Leland Wilkinson in 1999 and 2005
%   ``This book was written for statisticians, computer scientists, geographers, research and applied scientists, and others interested in visualizing data. It presents a unique foundation for producing almost every quantitative graphic found in scientific journals, newspapers, statistical packages, and data visualization systems. This foundation was designed for a distributed computing environment (Internet, Intranet, client-server), with special attention given to conserving computer code and system resources.''





\subsection{\emph{Layered Grammar of Graphics}}

The R data visualization package \ggplot is based on a \emph{Layered Grammar of Graphics} \cite{layered_grammar}.  During consulting meetings with students and faculty in helping them produce statistical visualizations of their data, the authors of the package noticed that many clients had trouble producing plots quickly and have difficulties understanding how the plots were generated.  This motivated them to develop the \ggplot package, which is based on the foundations of \emph{The Grammar of Graphics} \cite{}.

\subsection{\ggplot~layers}

Most of the standard statistical graphical displays take the form of single-layered plots.  For example, a scatterplot consists of a point layer while a boxplot contains a boxplot layer.  There is no formal name for the data graphic where horizontally jittered points are displayed on top of a vertical boxplot.  Each layer is understood as a component to the plot, therefore the plot as a whole can be understood.  Wickham did state that while a layered grammar guides a well formed graphic \cite{layered_grammar}, he analogizes ``good grammar is just the first step in creating a good sentence'' \cite{layered_grammar}.

Each plot consists of three components: the data, geom, and scales. Respectively, each of the component defines what is being displayed, how it is displayed and where it is being displayed.  By inferring from the supplied data source and geom defaults, many plots can be displayed without much coding.

<< geom_point, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap="Minimal coding for a scatterplot of \\rinline{tips} data." >>=
p <- ggplot(tips, aes(total_bill, tip)) +
  geom_point()
p
@

Typically, each layer of the plot uses the same original data source to help better explore the data frame.  Multi-layered plots may use multiple data sources where it would not be appropriate to combine data sources.  Added data sources are usally display contextual information, such as a map, or summary statistics, such as a mean or linear model.

<< tip_lm, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "Scatterplot with manual linear model line added to the panel." >>=
tip_lm <- broom::tidy(lm(tip ~ total_bill, data = tips))$estimate
(tip_lm_dt <- data.frame(
  intercept = tip_lm[1],
  slope = tip_lm[2]
))
p +
  geom_abline(
    data = tip_lm_dt,
    aes(slope = slope, intercept = intercept)
  )
@



% What is a layered plot


% Each layer allows for default argument values to be used instead of being supplied in every layer.  With decent default values, every argument does not need to be supplied as is described in Grammar of Graphics.

\subsection{Plot creation}

All plot layers do not need to exist at the time of plot object inception.  Each layer of a \ggplot~plot may be added one by one to the original plot object at different times of the code execution.  The simplist of plot objects consists of a default data set and a default set of aesthetics.

<< minimal_gg, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "Empty \\ggplot~plot with no layers displayed." >>=
minimal_plot <- ggplot(data = tips, aes(total_bill, tip))
# display delayed until print time
minimal_plot
@

No layers are displayed as none have been provided.  However, the scales have been infered from the default data aesthetics.

\subsection{Comparison}

Building the plot up layer by layer and storing it as an R object until printed does not follow existing patterns in R graphics.  The R core package \pkg{graphics}~\cite{r_project} displays information in a plot immediately upon function call.  There is no ability to delay the display of the plot after the initial plot has been created with the \pkg{graphics}~package.

<< graphics_plot, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "Stock R scatterplot using the \\pkg{graphics}~package." >>=
g <- graphics::plot(tip ~ total_bill, data = tips)
# nothing is stored, as plot is already displayed
g
@

\pkg{lattice}~graphics meets in between \ggplot~and \pkg{graphics}~as all layers must be supplied at plot creation, but the plot is not displayed until print time.  The prior two \ggplot~examples, (CITE FIGURE) and (CITE FIGURE), both displayed the ability to delay the printing of the \ggplot~plot object.  \pkg{lattice}~graphics can also delay the display of the plot object as both \pkg{lattice}~and \ggplot~convert their plot objects to be displayed using the \pkg{grid}~package at print time.  The \pkg{grid}~package does not implement full statistical plots, but rather it implements a R plotting framework to be used by other packages like \ggplot~and \pkg{lattice}.

<< lattice_xyplot, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "\\pkg{lattice}~scatterplot displaying using the \\pkg{grid}~framework." >>=
l <- lattice::xyplot(tip ~ total_bill, data = tips)
# display plot
l
@

Finally after executing the \pkg{graphics}~and \pkg{lattice}~code above, we can add a point layer to the minimal \ggplot~plot example.

<< minimal_point, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "Adding a `point' layer to the base \\ggplot~plot object." >>=
# layer added after plot inception
minimal_points <- minimal_plot + geom_point()
# displays plot
minimal_points
@

Modularization of the \ggplot~code allows for customization of each layer added to the plot. This leads to a smaller, more consistent interface with each layer function.



\section{Facets}

% This is very important
%   ggplot2 does not create new columns of information
%     only performs minimal, common statistical transformations on existing columns such as binning and density
%   ggplot2 does not divide the data up in `cut' formats that do not exist in input data
%     only divides data (facets) according to pre-existing column combinations


Winston Chang, maintainer of \ggplot, explains facet'ing as ``[ploting] subsets of data into separate panels'' \cite{chang2013rgc}.  This is achieved using existing conditioning variables in the supplied data set. Each panel produces similar plots.  This technique commonly refered to as small multiples \cite{small_multiples}.  The same plots are displayed, but each plot contains an independent subset of the data.  Typically, only one or two conditioning variables are used, but any number of variables may be used when faceting a \ggplot~plot.

Facets are useful when looking at the interaction with the conditioning variables.  Once all existing combinations of the conditioning variables have been made, subsets of the data are displayed in each of the panels with the strip (panel label) of the panel displaying the conditioning variable information.  Missing combinations can either be dropped or display an empty panel.  Facet wrap will drop missing combinations by default and facet grid will display an empty panel for missing combinations.  In \ggplot, all variables are considered discrete when used as faceting conditioning variables.



\subsection{Facet wrap}

There are two types of faceting in \ggplot: facet wrap and facet grid.  Facet wrap displays each panel row by row from left to right then top to bottom.  The number of rows and/or columns can be specified to ease the guessing work made by \ggplot.  If no facet row or column counts are supplied, \ggplot~attempts to give each uses \pkg{grDevices}~\cite{r_project} algorithm, \rinline{n2mfrow(n)}, to determine a sensible number of rows and columns.  Plots are display starting in the top row, from left to right, working towards the bottom of the plotting area.


<< facets1, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "$tip$ vs $total\\_bill$ with facets or conditioning variables." >>=
p <- ggplot(tips, aes(total_bill, tip)) + geom_point()
p +
  labs(title = "No Facets")
@
<< facets2, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "$tip$ vs $total\\_bill$ faceted by $day$. Each panel belongs to a given day in the data." >>=
p +
  facet_wrap(~ day, labeller = label_both) +
  labs(title = "Facet Wrap (~ day)")
@
<< facets3, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "$tip$ vs $total\\_bill$ faceted by all existing $day$ and $time$ combinations." >>=
p +
  facet_wrap(~ day + time, labeller = label_both) +
  labs(title = "Facet Wrap (~ day + time)")
@

\subsection{Facet grid}

Facet grid forces a two dimensional layout when faceting a plot.  The layout involves two sets of conditioning variables: the X conditioning and the Y conditioning variables.  These two sets of conditioning variables pre-determine how many rows (Y) and columns (X) are produced.

<< facet_grid_example, fig.width = 5, fig.height = 3.75, out.width = "4in", out.height = "3in", fig.cap = "$tip$ vs $total\\_bill$ faceted in a grid pattern with $time$ representing each row and $day$ representing each column." >>=
p +
  facet_grid(time ~ day, labeller = label_both) +
  labs(title = "Facet Grid (time ~ day)")
@

The plot above displays \rinline{time} on the rows ($y$) and \rinline{day} on the columns ($x$).  The \rinline{facet_grid} formula follows a typical linear model formula of \rinline{y ~ x}.  Multiple columns can be used in either the $x$ position or the $y$ position.  This allows the user the dipslay a set column combinations against another set of column combinations.

% do not change size
<< facet_grid_multi, fig.cap = "$tip$ vs $total\\_bill$ faceted in a grid pattern with $sex$ and $smoker$ combinations representing each row and $time$ and $day$ combinations representing each column." >>=
p +
  geom_smooth(method = lm, se = FALSE) +
  facet_grid(sex + smoker ~ time + day, labeller = label_both)
@

The plot above displays that both Male and Female smokers on Sunday Dinner do not follow a positive linear trend.
