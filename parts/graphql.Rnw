
% Extra cites
% https://en.wikipedia.org/wiki/Key-value_database
% https://en.wikipedia.org/wiki/Strong_and_weak_typing
% https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
% https://en.wikipedia.org/wiki/Application_programming_interface



\chapter{GraphQL}

Since 2012, Facebook has developed GraphQL: ``a backend agnostic data query language and runtime" (CITE).  GraphQL drastically reduces the number of server requests created by the browser by using a dynamic and nested query structure.  Using the Working Draft Specification for GraphQL (CITE) as guidance, \gqlr implements a full GraphQL server within R.  \gqlr allows users to supply their own R functions to satisfy the data requirements of a GraphQL query generated by the browser.


\section{Application Protocol Interfaces}

Application Protocol Interfaces (APIs) are the fundamental backbone of communication between machines.  They enable manchines to communicate with each other without needing to know how the responding machine comes to its answer.  Two convensions for an API: simple API and custom API.  Each API style has their own advantages and disadvantages.  GraphQL was created to address the disadvantages while keeping the advantages at the cost of strong typing the request.



\section{Application Protocol Interface}


There are two parties involved in every API communication: the requestor who submits a query and respondor who returns an answer.  The requestor submits a query, and the responder returns an answer that can be interpreted by the requestor.  The key point to the communication transaction is that the requestor does not need to know how the responder calculates their answer.

This layer of abstraction shields the requestor from knowing the nitty gritty implementation details of the responder.  It allows the responder to behave like a black box that will only respond to particular requests or queries.


In this thesis, I will address single response APIs as I am concerned with the request, not the response.  A single response API is an API that returns only one response to one answer.  I will not discuss streaming APIs in this thesis.

Throughout this section, I will use a calculator, `Calc', as my example responder.  The calulator will be have four internal functions: add, subtract, multiply, and divide.  These four internal function behave just like a regular calculator, but the true implementation of the calculator is hidden.

\subsection{Simple API}

There are two common styles of single response APIs: simple and custom response.
A simple API has a single end point, or place to send a request, for each style of question it knows how to answer.  The Calculator would contain four end points: add, subtract, multiply, and divide.  Each end point would require two numeric values as inputs and would respond with a single numeric value.  To concisely define a RESTful Calculator, we may state the following:

\begin{graphqlcode}
# GraphQL; Schema
type Calculator {
  add(A: Float, B: Float): Float,
  subtract(A: Float, B: Float): Float,
  multiply(A: Float, B: Float): Float,
  devide(A: Float, B: Float): Float
}
\end{graphqlcode}

\subsubsection{Advantages}

Without abstracting the function name, the number of request end points match the number of exposed functions.  There are no dynamically created functions; everything is static.  By fixing all request end points, software systems can be reliably built against one another.  Any software system can build their own logic as to how they solve their particular problems, but every software system will request from the same API.

The ease of use of a simple API made it very popular with HTTP internet websites with the REST API (CITE).  The four most common functions of HTTP's REST are ``GET'', ``PUT'', ``POST'', and ``DELETE''.

\begin{enumerate}
  \item GET: Retrieve the supplied location data only.
  \item PUT: Store supplied data the supplied location.
  \item POST: Add new data at the supplied location.
  \item DELETE: Remove data at the supplied location.
\end{enumerate}


\subsubsection{Disadvantages}

As is common in practice, databases have many tables with built in relationships. RESTful APIs usually only return information one layer deep.

When looking at the Calculator, it solves a single calculation problem in one step.  To solve a multiple calculation problem, it will take multiple requests to the Calculator.  For example, solving 1 + 2 + 3 + 4 + 5 will require 4 requests to the Calculator; one for each of the operations.

<< calc_add, eval = FALSE >>=
answer = Calculator::add(1, 2) # 3
answer = Calculator::add(answer, 3) # 6
answer = Calculator::add(answer, 4) # 10
answer = Calculator::add(answer, 5) # 15
@

No matter how the requests are altered, it will require 4 requests to the Calculator.  This can become a major disadvantage when required to make many, many requests to the API.

If we were to look at a person's friends of their friends, we would need the following Schema and data information:

\begin{graphqlcode}
# GraphQL; Schema
type Person {
  id: ID
  name: String
  age: Int
  sex: String
  friends: [ID]
}
\end{graphqlcode}

Each person has an ``id'', ``name'', ``age'', ``sex'', and a list of person id's for their ``friends''.  While having all of this information is useful, it can bloat the amount of information that is returned.  While the current example isn't too big, one could imagine adding a Person's favorite song lyrics to the Person object.  This would greatly increase the total amount of information returned for each person.

\subsubsection{REST and the Internet}

In the case of the internet, however, two major constraints exist.  The two major constraints are the number of parallel requests that can be made at one time and the amount of time it takes for your request to reach a responding server.

HTTP 1.1 specification states that ``A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy'' (CITE \url{https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html}).  In practice, this is a little larger, maxing out at 13 parallel connections to the same host (CITE - \url{http://www.browserscope.org/?category=network&v=top}).  Limiting the number of server connections reduces the amount of simultanious requests on the network and improves overall response time.

Once a request is allowed to be made, there is some physical limitations on how fast the response can be made.  On average, it takes still takes over 200 ms for a request to make a round trip to the responding server and back to the user's browser (CITE - \url{https://www.internetweathermap.com/map}).

Using the Friend example above with each person having 200 different friends (the median number of friends on Facebook (\url{http://bigthink.com/praxis/do-you-have-too-many-facebook-friends}), let's calculate how much time it takes to gather the names of a person's friends of friends using a simple REST API. It would require $O(n^2) (200^2 = 40,000)$ independent requests to the server.  If the browser being used is limited to 10 parallel connections, it would require $4000 (= 40,000 / 10)$ sets of parallel request groups.  Each parallel request group takes at least 200ms for a round trip request.  The total amount of time it would require to gather the names of a person's friends of friends would take $13 \frac{1}{3} minutes = 200^2 / 10 * 0.200 / 60$.

The median loading time for a website is about 3 seconds with the average around 5 seconds. (\url{https://www.webdesignerdepot.com/2016/02/how-slow-is-too-slow-in-2016/}).  No major website would survive if the load time was 160 times slower than the average website.

% With the average website is now requiring more than 100 requests per page (http://www.websiteoptimization.com/speed/tweak/average-number-web-objects/), website turn around is decreasing.


\section{Custom Response}

A natural response to the Friends of Friends situation above is, ``Why not make a custom response?'' A custom route answers a specific question.

Because it answers one specific question, only one request to the server needs to be made.  The Friends of Friends example could be reduced to a single 200 ms request.  The load time is now reduced from 800 seconds to 0.2 seconds.  This answers the question in the minimal amount of queries to the server.

\subsection{Disadvantages}

The disadvantages come from the amount of engineering time is required to implement a custom response for every query.  With a simple query interface, the logic is put on the user who is querying to figure out what to query next.  With a custom response interface, all custom responses must be made before the user can request them.

Using the Calculator example, calculating the $1 + 2 + 3 + 4 + 5$ example could be done in a single custom request called ``1add2add3add4add5''.  It would solve the answer in a single request, but the server would have to implement many, many responses for all the funtionality of a Calculator.

The custom response is now tied directly to the requesting website.  This creates little separation between the website and the responding server.  By coupling the data server with the requesting service makes advancement by the requestor very slow and difficult.  Users making the requests can not move ahead until a new custom response has been enabled.

\section{Balancing Act}

Let's recap the advantages and disadvantages of the two different styles of APIs.

\begin{enumerate}
  \item Simple API
    \begin{enumerate}
      \item Advantages
        \begin{enumerate}
          \item Small API
          \item Easier to implement
        \end{enumerate}
      \item Disadvantages
      \begin{enumerate}
        \item Many queries are required to solve complex problems
        \item Many queries causes large time complexity
        \item All information pieces are returned
      \end{enumerate}
    \end{enumerate}
  \item Custom Responses
    \begin{enumerate}
      \item Advantages
        \begin{enumerate}
          \item One query, one answer
          \item All logic is hosted on data server
        \end{enumerate}
      \item Disadvantages
        \begin{enumerate}
          \item Many custom routes
          \item Data server is tied to requests made
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

% It is a balancing act to use a simple API, which causes more requests, and a

Developers balance between minimal engineering time and minimal execution time.  Typically the final result falls somewhere inbetween, using a custom API for high execution time queries and using a simple API for smaller queries.



\section{Variable Typing}

Programing languages know the type of objects in two ways: stong typed and weakly typed.  Strong typed languages know ``whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function.'' (CITE \url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.136.3043}) Weakly typed languages allow a programmer to passively use a invalid type as if it was correct.  A good example of this is when a String is added to an Integer.  As in Javascript (CITE), the Integer is converted to a String, then the two Strings are concatinated together.

\begin{jscode}
// javascript
42 + "hello"
// "42hello"
\end{jscode}

In a strong typed language like C (CITE), adding an Integer and String would not be allowed to compile.  A String in C does not know how to ``add'' like and Integer.

\begin{ccode}
// c
int x = 10;
char y[5] = "hello";
int z = x + y;
// file.c:3:10: warning: initialization makes integer from pointer
//   without a cast [-Wint-conversion]
// char z = x + y;
//          ^
// file.c:3:10: error: initializer element is not constant
\end{ccode}


\section{Database Storage}

Similarly, databases can store objects in two ways: as a relational database or as a key-value database.  Relational databases know exactly what kind of object will be returned and can map one table to another with id values.  Key-value databases, on the other hand, do not inspect the values of the database.  The only requirement is that values are stored at a specific key.  Key-value databases are built for speed and scalibility over structure and relationships.

While relational databases are already strongly typed (unless purposely stated as an unknown type), well designed key-value databases inherintly contain strong typed values.  Each value that is inserted into the database has a known shape and expected reponse type.  If data of an image is stored, audio data should never be returned from that same position.  Even if the image had different sizes and formats, it still can be understood as an image.

There are many more comparisons and cost / benefits to every database, however these implementation differences are not apart of the scope of this chapter.

\chapter{GraphQL}


GraphQL is a data query language built to unify data APIs.  It exists as a execution layer between the requesting user and responding database.  This abstraction layer provides many benefits from uniform request and response shape, dynamic queries to handle custom situations, and minimal server requests.

\section{Language}

GraphQL is comprised of two main parts, the Request and the Schema.

\subsection{Schema}


GraphQL Schemas are defined using Scalars, Types, Enumerations, Lists, Non-Null types, Interfaces, Unions, and Input types.  Each definition is used to define type or type abstractions that can be used when querying.  The Types represent the exepected return objects that the database already knows about.  Like most objects, each Type will contain fields that point to Scalars or more Types.  These fields can be queried recursively.

\subsubsection{Object Type Definition}

For example, we can setup a Schema for a professional baseball player.

\begin{graphqlcode}
type Dog {
  name: String
  breed: String!
  owner: [Person!]!
}
\end{graphqlcode}

The type definition for a \graphqlinline{Player} above is very readible, but has a lot going on.

\begin{enumerate}
  \item \graphqlinline{Dog} is a Object Type definition.  It has four fields:  \graphqlinline{name}, \graphqlinline{breed}, \graphqlinline{age}, and \graphqlinline{owner}.  These four fields are the only fields allowed when retrieving information from a \graphqlinline{Dog}.
  \item \graphqlinline{String} is a predefined Scalar type definition.  This would contain the dog's name, i.e. ``Clifford''.  Scalar fields do not contain any sub fields and are considered leafs in the Schema definition tree.
  \item \graphqlinline{String!} represents a Non-null String value.  This means that all \graphqlinline{Dog} objects will contain the \graphqlinline{breed} field and the result will always be a String.
  \item \graphqlinline{[Person]} represents an array of Person objects that represent the owner of the Dog. By adding the \graphqlinline{!} outside the array to form \graphqlinline{[Person]!}, it will be gaurunteed to return an array for the field \graphqlinline{owner} and never a \graphqlinline{NULL} value.  By adding a \graphqlinline{!} to the Person (\graphqlinline{[ Person!]!}), the elements inside the position array will never be \graphqlinline{NULL}.  A length $0$ array is still allowed as the \graphqlinline{owner} value is not \graphqlinline{NULL} and all values are not \graphqlinline{NULL}.
\end{enumerate}


\subsubsection{Argument and Input Type Defintions}

Field definitions may include arguements.  These arguments can be simple Scalar definitions or Input Type definitions.

\begin{graphqlcode}
# GraphQL; Schema
input ToyInput {
  brand: String
  name: String
  condition: Condition
}
extend type Dog {
  weight(unit: WeightUnit = POUNDS): Float
  does_play_with_toy(toy: ToyInput): Boolean
}
\end{graphqlcode}

Like the R language, all arguments are named arguments, all arguments may be submitted in any order, and default values may be provided.  Unlike R, all submitted arguments must have a name and must comply with the argument type.  Default values may be used are used in place of missing arguments.

\subsubsection{Schem Type Definition}

There are two main entry points to a Schema: schema query type and schema mutation type. Every GraphQL Schema definition must have a schema query type and optionally can have a schema mutation type.  Each of these types refer to the type of an object type definition.

\begin{graphqlcode}
# GraphQL; Schema
schema {
  query: Dog
  mutation: DogUpdate
}
\end{graphqlcode}

Query types are read only, while mutation types are understood that something will update in the database.  A request will have the same shape for both query types and mutation types.

\subsection{Scalar Type Definitions}

Scalar Types are the leafs of the Schema.  Unlike Object Types, Scalars do not have fields to inspect.  GraphQL defines the base scalars as a part of the language definition:

\begin{enumerate}
  \item \graphqlinline{Boolean}: $true$ or $false$
  \item \graphqlinline{Integer}: A signed 32-bit integer
  \item \graphqlinline{Float}: A signed double-precision floating point value
  \item \graphqlinline{String}: A UTF-8 character sequence
  \item \graphqlinline{ID}: \graphqlinline{ID} performs the same as a \graphqlinline{String}, but it is intended to be machine readible only as a unique identifier
\end{enumerate}

New scalars can be defined in a Schema as long as the server running the GraphQL understands how to handle them.

\begin{graphqlcode}
# GraphQL; Schema
scalar Date
scalar Binary
scalar Hexadecimal
\end{graphqlcode}



\subsection{Enumeration Type Definitions}

GraphQL understands a finite category variable.  This is similar to a factor in R.  There are a fixed set of values for every Enum definition.  Internally in the GraphQL server, it may be stored as an Integer value or an object similar to a Set, but in the GraphQL language, it will be represented as an all capitol string, such as \graphqlinline{POUNDS}.

\begin{graphqlcode}
# GraphQL; Schema
enum WeightUnit {
  POUNDS
  KILOS
  OUNCES
}
\end{graphqlcode}

Whenever a WeightUnit type is expected, only the values of \graphqlinline{POUNDS}, \graphqlinline{KILOS}, or \graphqlinline{OUNCES} may be used.  While R supports factor values, and full Enum class was created in the \gqlr R package.


\subsection{Interfaces}

Interfaces are an integral part in abstracting pieces of information.  They allow for common fields to be accessed on objects without known the true type of the object.  All types that inherit the interface must implement all fields of that interface.  So any type that implements \graphqlinline{Pet}, must implement the fields \graphqlinline{name} and \graphqlinline{owners} and return \graphqlinline{String} and \graphqlinline{[Person!]!} respectively.

\begin{graphqlcode}
# GraphQL; Schema
interface Pet {
  name: String
  owners: [Person!]!
}
type Dog implements Pet {
  name: String
  barkVolume: Int
  owners: [Person!]!
}
type Cat implements Pet {
  name: String
  meowVolumn: Int
  owners: [Person!]!
}
\end{graphqlcode}

Object may implement extra fields, like \graphqlinline{meowVolume} in \graphqlinline{Cat}.

Interfaces are useful when queries are made on objects where the exact return type is not known, but a finite set of types exist for the expected value.

\begin{graphqlcode}
# GraphQL; Schema
extend type Person {
  pet: [Pet!]! # returns an array of Cat or Dog types
}
\end{graphqlcode}

Object definitions may interface with many Interface definitions.

\subsection{Union Type Definition}

Unions contain a finite set of Object types, but do not specify and common fields.  Unions are not allowed to contain other unions or interfaces.

\begin{graphqlcode}
# GraphQL; Schema
extend type Cat {
  weight(unit: WeightUnit = KILOS): Float
}
union NotAPlant = Person | Dog | Cat
\end{graphqlcode}

Results being returned could either be a \graphqlinline{Person}, \graphqlinline{Dog}, \graphqlinline{Cat}, or \graphqlinline{Shark} type.  All of the types included in \graphqlinline{NotAPlant} do not share a common field, but could feasibly be returned in the same field of information.


\section{Requests}

The following Schema will be used within the Requests section.

\begin{graphqlcode}
# GraphQL; Schema
scalar Date
enum WeightUnit {
  POUNDS
  KILOS
  OUNCES
}
type Person {
  name: String!
  weight(unit: WeightUnit = POUNDS): Float
  friends: [Person!]!
  pets: [Pet!]!
}
\end{graphqlcode}
\begin{graphqlcode}
interface Pet {
  name: String
  born: Date
  owners: [Person!]!
}
type Dog implements Pet {
  name: String
  barkVolume: String
  born: Date
  owners: [Person!]!
}
type Cat implements Pet {
  name: String
  born: Date
  meowVolume: String
  owners: [Person!]!
}
union SearchResult = Person | Dog | Cat
\end{graphqlcode}
\begin{graphqlcode}
type Query {
  search_name(name: String!): SearchResult
  person(name: String! = "Mickey Mouse"): Person
  dog(name: String! = "Pluto"): Dog
  cat(name: String! = "Figaro"): Cat
}
schema {
  query: Query
}
\end{graphqlcode}


\subsection{Queries}

Every object in the Schema definition can be queried.  A query on an object type must include at least one field.  Object types are not considered leafs in the Schema definition tree as they are guarenteed to have at least one field.

% \begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}

\begin{graphqlcode}
# GraphQL; Query
{
  person {
    name
  }
}
\end{graphqlcode}

% &

\begin{jscode}
// JSON; GraphQL Response
{
  "data":{
    "person": {
      "name": "Mickey Mouse"
    }}}
\end{jscode}

% \end{tabular}

Queries have the same shape has the result.  The only difference occurs when a result is an array of information.  Using an \graphqlinline{name} arugment below, we can look at Jim Dear's pets from the movie ``Lady and the Tramp''.

% \begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}

\begin{graphqlcode}
# GraphQL; Query
{
  person(name: "Jim Dear") {
    name
    pets {
      name
    }}}
\end{graphqlcode}

% &

\begin{jscode}
// JSON; GraphQL Response
{
  "data":{
    "person": {
      "name": "Jim Dear",
      "pets": [
        { "name": "Lady" },
        { "name": "Tramp" }
      ]}}}
\end{jscode}

(CITE \url{http://disney.wikia.com/wiki/Jim_Dear})

% \end{tabular}


The whole query string is submitted to the GraphQL server.  This allows for complex and deeply nested queries in a single request.  Using the query below, we can query for all pets owned by the same owners as Duchess the cat.

% \begin{tabular}{p{0.2\textwidth} p{0.65\textwidth}}

\begin{graphqlcode}
# GraphQL; Query
{
  cat(name: "Duchess") {
    owners {
      name
      pets {
        name
      }}}}
\end{graphqlcode}

% &

\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "cat": {
      "owners": [{
        "name": "Madame Adelaide Bonfamille",
        "pets": [
          {"name": "Duchess"},
          {"name": "Marie"},
          {"name": "Berlioz"},
          {"name": "Toulouse"},
          {"name": "Thomas O'Malley"}
        ]}]}}}
\end{jscode}

(CITE \url{http://disney.wikia.com/wiki/Madame_Adelaide_Bonfamille})

% \end{tabular}

Normally the code above would require $O(k * n)$ requests in a simple API, with $k$ owners and $n$ pets belonging to each owner.  With GraphQL, this query is resolved in one request and without the need for a custom API to be built.




\subsubsection{Aliases}

Aliases can be used to query the same object field many times.


% \begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}

\begin{graphqlcode}
# GraphQL; Query
{
  duchess: cat(name: "Duchess") {
    name
    meowVolume
  }
  rajah: cat(name: "Rajah") {
    name
    meowVolume
  }}
\end{graphqlcode}

% &

\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "duchess": {
      "name": "Duchess",
      "meowVolume": 2
    },
    "rajah": {
      "name": "Rajah",
      "meowVolume": 9
    }}}
\end{jscode}

% \end{tabular}


\subsubsection{Fragments}

For conciseness, the query above can be made with Fragments.  Fragments can be used when repeated fields are called on similar objects.

The same result will occur using the Fragments below.

% \begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}

\begin{graphqlcode}
# GraphQL; Query
{
  duchess: cat(name: "Duchess") {
    ..catFields
  }
  rajah: cat(name: "Rajah") {
    ...catFields
  }
}
fragment catFields on Cat {
  name
  meowVolume
}
\end{graphqlcode}

% &

\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "duchess": {
      "name": "Duchess",
      "meowVolume": 2
    },
    "rajah": {
      "name": "Rajah",
      "meowVolume": 9
    }}}
\end{jscode}

% \end{tabular}


Fragments are very useful in breaking down complicated queries into smaller sections.

\subsection{Mutation}

Mutations are the ``write'' to a database.  Mutations also return information to avoid a ``read'' immediately afterwards.  While there is no guarentee that a Query does not alter the database, it is a good practice to distinguish which commands read only and which commands write to the database.

% \begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}

\begin{graphqlcode}
# GraphQL; Schema
type MutationType {
  # returns total wealth after adding amount
  addToWealth(name: String!, amount: Float): Float
}
\end{graphqlcode}

\begin{graphqlcode}
# GraphQL; Mutation
mutation {
  addToWealth(name = "Scrooge", amount = 1000)
}
\end{graphqlcode}

% &

\begin{jscode}
// JSON; GraphQL Response
{
  "data": {
    "addToWealth": 28800000
  }}
\end{jscode}

(CITE: \url{http://disney.wikia.com/wiki/Scrooge_McDuck})

% \end{tabular}


\subsection{Remaining GraphQL Language}

There are many more intricacies in the GraphQL language that are not in the scope of this paper.



\section{\gqlr}

\gqlr is an R package that implements a GraphQL server.  \gqlr handles Query and Mutation Requests and returns data in the proper format.  It is built upon the next evolution of class definitions in R, $R6$.

\subsection{R6}

R6 is a lightweight R package that creates objects that do not follow the particular conventions of R.  R known for being ``pass by value''. This means that all values are copied at the beginning of a function. Like many other languages, R does not have dynamic values for a list object.

<< pass_by_value >>=
my_list <- list(A = TRUE, B = FALSE)
my_list$A
update_A_to_false <- function(x) {
  x$A <- FALSE
  x
}
update_A_to_false(my_list)
my_list
@

The example above does not update the value of A to \rinline{FALSE} as the value \rinline{my_list} was copied at the beginning of the function \rinline{update_A_to_false}.

R6 allows for objects to be altered inside functions that they have been passed to without any changes in assignment method.  This is similar to a ``pass by reference'' coding paradigm.  An R6 object is passed to a function and the function alters the value.  The same R6 object outside of the function has been altered as well.  This is not expected R behavior.

R6 does this through the use of Classes.  Classes are built similar to Javascript's ES6 classes.  There can be a constructor, methods, and values.  The methods and values can be both private (only able to be seen internally) and public (available to any function).  Like Javascript, there is a notion of the ``this'' value or an object representing itself.  R6 uses the ``self'' object in this case.  Values within the same object can be retrieved using \rinline{value <- self\$key}.


<< library_r6, echo = FALSE, cache = FALSE >>=
library(R6)
library(gqlr)
library(magrittr)
@

<< gqlr_minimal >>=
Minimal <- R6Class("Minimal",
  public = list(
    name = NULL,
    initialize = function(name = NA) {
      self$name <- name
      self$greet()
    },
    greet = function() {
      cat(paste0("Hello, my name is ", self$name, ".\n"))
    }
  )
)
barret <- Minimal$new("Barret")
barret$name
update_name_to_schloerke <- function(x) {
  x$name <- "Schloerke"
  invisible(x)
}
update_name_to_schloerke(barret)
barret$name
@


R6 also allows for dynamic queries.  R6 calls these ``active fields''.  These fields are actually function calls, but appear a regular keys in the object.  The active key function can handle a single argument.  This argument represents the value of the object being stored.  If no value was supplied, then the active key was retrieved, not set.

In the example below, a single active key of $random$ will return a uniform value when retrieved and will set the random seed if the $random$ key is set.  After the key is set to $1234$, as expected, the same random values are returned.

<< gqlr_minimal_active >>=
MinimalActive <- R6Class("MinimalActive",
  active = list(
    random = function(x) {
      if (missing(x)) {
        return(runif(1))
      }
      set.seed(x)
      TRUE
    }
  )
)
min_active <- MinimalActive$new()
min_active$random
min_active$random
min_active$random <- 1234
min_active$random
min_active$random
min_active$random <- 1234
min_active$random
@

Finally, R6 allows for inheritance.  In the GraphQL's abstract syntax tree, many objects inherit from one another in a directed, acyclic graph structure.  This is similar

<< gqlr_inheritance >>=
ParentClass <- R6Class("ParentClass")
ChildClass <- R6Class("ChildClass", inherit = ParentClass)
child <- ChildClass$new()
class(child)
inherits(child, "ParentClass")
@

In \gqlr, all active values must inherit the correct class to be allowed to set.  Errors will be thrown if a value does not contain the proper inheritance.  The example below shows the creation of a named type ``Dog''.  It also shows an attempt at setting the $name$ value to a character.  This is not allowed as $name$ value only allows objects that inherit objects of class ``Name''.

<< named_type_dog >>=
(obj <- gqlr:::NamedType$new(name = gqlr:::Name$new(value = "Dog")))
str(obj$name)
obj$name <- "Dog"
@


\gqlr uses these active fields to accomplish strong typed language properties while executing in a weakly typed language of R.  This has an unnatural feeling during coding, but is highly effective in implementing GraphQL.

\subsection{Execution}

At first glance, R and GraphQL seem like an unlikely combination.  R is a weakly typed language while GraphQL is a strong typed language.  R is not necessarliy known for its raw speed and one of GraphQLs goals is to reduce execution time.

However, R is known for its statistical models (CITE linear models, loess, and ?), statistical graphics (CITE Lattice, and ggplot2), and its very fast iteration speed.  Leveraging the 10,000+ packages (CITE) available to R, R users do not have to rewrite the wheel.  \gqlr is built to help small projects provide proof of concept or developers to mock full backend systems locally.

Switching between a mock server and a production server should not be a headache.  GraphQL is built as a data server that returns JSON. Whether it wraps to a full production server or sits in a local R session should not matter to the browser's requests.

The example below creates a model schema that creates a linear model and a loess model.  Both models return the mean squared error (mse) for their respective models.  The linear model also returns a GGally's ggnostic plot which is data64 encoded for portability.  The loess model also returns the effective number of parameters (enp).

<< setup_execute >>=

"
# GraphQL; Schema
scalar Data64
type LinearModel { mse: Float!, ggnostic: Data64! }
type LoessModel { mse: Float!, enp: Float! }
type Model {
  linear(formula: String, data_name: String): LinearModel
  loess(formula: String, data_name: String): LoessModel
}
schema { query: Model }
" %>%
  gqlr::gqlr_schema(
    Data64 = function(p, schema) {
      tmp_file <- tempfile(fileext = ".png")
      on.exit(unlink(tmp_file))
      ggplot2::ggsave(tmp_file, p)
      knitr::image_uri(tmp_file) %>%
        substr(start = 1, stop = 40) %>%
        paste0("...")
    },
    LinearModel = function(model, schema) {
      list(
        mse = mean(model$residuals ^ 2),
        ggnostic = function(...) {
          GGally::ggnostic(model)
        })},
    LoessModel = function(model, schema) {
      list(
        mse = mean(model$residuals ^ 2),
        enp = model$enp
      )},
    Model = function(ignore, schema) {
      model_ <- function(fn_) {
        function(null, args, schema) {
          formula_ <- as.formula(args$formula)
          data_ <- eval(as.symbol(args$data_name))
          fn_(formula_, data = data_)
        }}
      list(
        linear = model_(stats::lm),
        loess = model_(stats::loess)
      )}) ->
model_schema

@

In about 40 lines of code, a schema definition and execution methods can be implemented.  To build a strong typed API and its corresponding implementation in less than 100 lines of code is a feat.  With \gqlr, we are able to do it in less than half the lines of code.

In the implementation, four major R packages are called.

\begin{enumerate}
  \item $stats$ is used for the linear model function and loess function.
  \item $GGally$ is used to call its model diagnostic plot matrix.
  \item $gglot2$ is used to save the plot objected created by $GGally$.
  \item $knitr$ is used for its ability to data64 encode images saved by $ggplot2$.
\end{enumerate}

These packages are built upon many other R packages and displays the extensibility of a schema execution.

To see the Model schema in action, we can execute a request using the classic R dataset ``iris''.


<< execute_graphql >>=

'
# GraphQL; Query
{
  linear(
    formula: "Petal.Length ~ Petal.Width",
    data_name: "iris"
  ) {
    mse,
    ggnostic
  }
  loess(
    formula: "Petal.Length ~ Petal.Width",
    data_name: "iris"
  ) {
    mse,
    enp
  }
}' %>%
  gqlr::execute_request(schema = model_schema) ->
result
@

<< print_result >>=
result
@

While R users might not find the query and output very compelling (as they can be done in a regular R session), it is good to remember that any web service with access to the Model Schema above can execute a similar command and get an answer that is executed by R.  During the request execution, \emph{any} R package can be used.  Being able to open the flood gates to R's extensive package list is very powerful. This means that javascript in the browser and a python program can retrieve full R plots and R model outputs without having to implement the methods in the local language while using the same API.

This schema can also be executed in a local GraphQL server session or on a production GraphQL server.  Both the local and production servers have the same schema, so each service will return the same shapes.  Each programming language will have the same query string and receive the same shaped response.



\subsection{Web Service}

A simple web server is included in \gqlr, but extending the web server to other url routes and authentication services are not included.  \gqlr was built to handle GraphQL requests and leave the url routing and authentication to better suited packages.  While some may argue for a single, go-to R package, there are many existing URL request handlers and authenticators existing for R.




% There is a unique API or interaction method to query every database.  When making a database call to a MySQL server, there is a known SQL syntax for interacting with the relational database.  When making a database call to a MongoDB server, there is a different, known syntax for interacting with the NoSQL database.  For every known database, there is a unique language created to interact with the data.  If a database needs to be updated to a different database or is even upgraded to a new version, the query syntax, more often than not, is broken.  This leads to continuous integration with the query syntax and the database and constant reprogramming of the query syntax for every update of the database syntax.  GraphQL addresses this issue.
